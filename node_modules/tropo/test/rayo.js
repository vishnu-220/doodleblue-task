var Rayo = require('../lib/rayo')
var util = require('util');
var events = require('events');
var XmlElement = require('../lib/utils').XmlElement;
var parseXml = require('../lib/utils').parseXml;

var client = null;

process.on('uncaughtException', function(err) {
	console.log('Caught exception: ', err, err.stack);
	process.exit(1);
});


var MockTransport = require('../lib/rayo-mock.js'); 

module.exports = {

   setUp: function(callback) {
      client = new Rayo({}, new MockTransport());
      callback();
   },
   
   tearDown: function(callback) {
	 
	   client.dispose();
	   callback();
   },

   'Incoming offer should produce event': function(test) {

      test.expect(2);

      client.on('offer', function(call) {
         test.equals(call.callId, 'foo', 'Unexpected Call ID');
         test.equals(call.connectionId, 'bar', 'Unexpected Connection ID');
         test.done();
      });

      newCall();

   },

   'Build and send <answer> Call command': function(test) {

      test.expect(3);

      client.transport.send = function(command ) {
         test.equals(command.callId, 'foo', 'Unexpected Call ID');
         test.ifError(command.connectionId, 'Unexpected Connection ID');
         test.equals(command.body.getName(), 'answer', 'Unexpected Element Name');
         test.done();
      };

      client.on('offer', function(call) {
         call.command('answer').send();
      });

      newCall();

   },

   'Build and send <answer> Connection command': function(test) {

      test.expect(3);

      client.transport.send = function(command ) {
         test.equals(command.callId, 'foo', 'Unexpected Call ID');
         test.equals(command.connectionId, 'bar', 'Unexpected Connection ID');
         test.equals(command.body.getName(), 'answer', 'Unexpected Element Name');
         test.done();
      };

      client.on('offer', function(call) {
         call.command('answer','bar').send();
      });

      newCall();

   },

   'Build and send <redirect> with callback': function(test) {

      test.expect(4);

      client.on('offer', function(call) {

         call.command('answer').send(function(err, result) {
            test.ok(true, 'Callback was invoked');
            test.equals(call, this, 'Value of this does not match call object');
            test.done();
         });

     	process.nextTick(function() {
            client.transport.next(function(command, callback) {
	            test.equals(command.callId, 'foo', 'Unexpected Call ID');
	            test.equals(command.body.getName(), 'answer', 'Unexpected Element Name');
	            callback(null, null);
	         });
     	});
      });

      newCall();

   },

   'Tropo Call is adding connections on offer': function(test) {

      test.expect(2);

      client.on('offer', function(call) {
         test.ok(client.tropoCalls[call.callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections');
         test.done();
      });

      newCall();
   },
	   
   'Tropo Call is adding connections on joining': function(test) {

      test.expect(3);

      client.on('offer', function(call) {
         test.ok(client.tropoCalls[call.callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections');
      });
      
      client.on('joining', function(event) {
	         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
	         test.equals(conns,2, 'Wrong number of connections');
	         test.done();	    	  
      });

      newCall();
      
      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('announce').c('joining', {'call-id':'bar2', to:'sip:somone@somewhere'}).up()
       });
   },
   
   'Tropo Call is cleaning connections on end': function(test) {

      test.expect(5);

      client.on('offer', function(call) {
         test.ok(client.tropoCalls[call.callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections');
         
         call.on('end', function(el) {
	         test.ok(client.tropoCalls[call.callId] != null, 'Call was cleaned up!');
	         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
	         test.equals(conns,1, 'Wrong number of connections');
             test.done();
          });

      });
      
      client.on('joining', function(event) {
	         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
	         test.equals(conns,2, 'Wrong number of connections');
      });

      newCall();
      
      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('announce').c('joining', {'call-id':'bar2', to:'sip:somone@somewhere'}).up()
       });
      
      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('end')
       });
   },
 
   'Tropo Call is not cleaned up after connection <end>': function(test) {

      test.expect(1);

      client.on('offer', function(call) {
         call.on('end', function(el) {
            console.log('On test call id is: ' + client.tropoCalls[call.callId]);
            test.ok(client.tropoCalls[call.callId] != null, 'Call was cleaned up!');
            test.done();
         });
      });

      newCall();

      event({
         callId: 'foo',
         connectionId: 'bar',
         body: new XmlElement('end')
      });
   },
   
   'Tropo Call is cleaned up after call <end>': function(test) {

      test.expect(2);

      client.on('offer', function(call) {
         // note that here we are dealing with "rayoCalls" a.k.a. connections/legs so 'end' event is not 
         // actually when the call has been disposed
         call.on('end', function(el) {
            console.log('On test call id is: ' + client.tropoCalls[call.callId]);
            test.ok(el); // cool, we got the leg end event
            process.nextTick(function() {
                // After the event loop iteration, validate that call was disposed
                test.ok(client.tropoCalls[call.callId] == null, 'Call was cleaned up!');
                test.done();
            });  
         });
      });

      newCall();

      event({
         callId: 'foo',
         body: new XmlElement('end')
      });
   },   
  
   'Tropo Call is not cleaned up after <end> when with pending components': function(test) {

      test.expect(4);

      client.on('offer', function(call) {
         var id = call.callId;
         var tropoCall = client.tropoCalls[id];
         test.ok(tropoCall != null, 'Call was not set up!');
         call.on('end', function(el) {
            setTimeout(function() {
                test.ok(client.tropoCalls[id] != null, 'Call was cleaned up!');
                test.done();
            }, 500);
         });
         call.component('output').c('audio', {url: 'http://sounds.com/intro.mp3'}).up().start(function(err, component) {
            test.equals(component.id, 'bar', 'Unexpected Component ID');
         });

         process.nextTick(function() {
             client.transport.next(function(command, callback) {
                callback(null, new XmlElement('ref', {id:'bar'}));
             });
             test.equals(Object.keys(client.tropoCalls[id].components).length,1);
             event({
                 callId: 'foo',
                 connectionId: 'bar',
                 body: new XmlElement('end')
            });             
         });                  
      });

      newCall();
   },
   'Tropo Call is cleaned up after call <end> even with pending components': function(test) {

      test.expect(4);

      client.on('offer', function(call) {
         var id = call.callId;
         var tropoCall = client.tropoCalls[id];
         test.ok(tropoCall != null, 'Call was not set up!');
         call.on('end', function(el) {
            setTimeout(function() {
                test.ok(client.tropoCalls[id] == null, 'Call was not cleaned up!');
                test.done();
            }, 500);
         });
         call.component('output').c('audio', {url: 'http://sounds.com/intro.mp3'}).up().start(function(err, component) {
            test.equals(component.id, 'bar', 'Unexpected Component ID');
         });

         process.nextTick(function() {
             client.transport.next(function(command, callback) {
                callback(null, new XmlElement('ref', {id:'bar'}));
             });
             test.equals(Object.keys(client.tropoCalls[id].components).length,1);
             event({
                 callId: 'foo',
                 body: new XmlElement('end')
            });             
         });                  
      });

      newCall();
   },     

   'Start <output> component and send it a <pause> command': function(test) {

      test.expect(5);

      client.on('offer', function(call) {

         call.component('output').c('audio', {url: 'http://sounds.com/intro.mp3'}).up().start(function(err, component) {

            test.equals(component.id, 'bar', 'Unexpected Component ID');

            component.command('pause').send(function(err, result) {
               test.ok(err == null && result == null);
               test.done();
            });

            // Process the pause command
            process.nextTick(function() {
	            client.transport.next(function(command, callback) {
	               test.equals(command.body.attrs.xmlns, 'urn:xmpp:rayo:output:1');
	               test.equals(command.callId, 'foo', 'Unexpected Call ID');
	               test.equals(command.componentId, 'bar', 'Unexpected Component ID');
	               callback(null, null)
	            });
            });
         });

         process.nextTick(function() {
	         client.transport.next(function(command, callback) {
	            callback(null, new XmlElement('ref', {id:'bar'}));
	         });
         });
      });

      newCall();

   },
  
   'Start <record> component and send it a <pause> command': function(test) {

      test.expect(5);

      client.on('offer', function(call) {

         call.component('record').up().start(function(err, component) {

            test.equals(component.id, 'bar', 'Unexpected Component ID');

            component.command('pause').send(function(err, result) {
               test.ok(err == null && result == null);
               test.done();
            });

            // Process the pause command
            process.nextTick(function() {
	            client.transport.next(function(command, callback) {
	               test.equals(command.body.attrs.xmlns, 'urn:xmpp:rayo:record:1');
	               test.equals(command.callId, 'foo', 'Unexpected Call ID');
	               test.equals(command.componentId, 'bar', 'Unexpected Component ID');
	               callback(null, null)
	            });
            });
         });

         process.nextTick(function() {
	         client.transport.next(function(command, callback) {
	            callback(null, new XmlElement('ref', {id:'bar'}));
	         });
         });
      });

      newCall();

   },
   
   'Start <record> component and send it a <resume> command': function(test) {

      test.expect(5);

      client.on('offer', function(call) {

         call.component('record').up().start(function(err, component) {

            test.equals(component.id, 'bar', 'Unexpected Component ID');

            component.command('resume').send(function(err, result) {
               test.ok(err == null && result == null);
               test.done();
            });

            // Process the pause command
            process.nextTick(function() {
	            client.transport.next(function(command, callback) {
	               test.equals(command.body.attrs.xmlns, 'urn:xmpp:rayo:record:1');
	               test.equals(command.callId, 'foo', 'Unexpected Call ID');
	               test.equals(command.componentId, 'bar', 'Unexpected Component ID');
	               callback(null, null)
	            });
            });
         });

         process.nextTick(function() {
	         client.transport.next(function(command, callback) {
	            callback(null, new XmlElement('ref', {id:'bar'}));
	         });
         });

      });

      newCall();

   },     

   'Component cleanup. Complete due to hangup': function(test) {

      test.expect(2);

      client.on('offer', function(call) {

         call.component('output').c('audio', {url: 'http://sounds.com/intro.mp3'}).up().start(function(err, component) {
            component.on('complete', function(el) {
               test.ok(call.components[component.id] == null);
               test.equals(el.children[0].getName(), 'hangup');
               test.done()
            });

         });

         process.nextTick(function() {
	         client.transport.next(function(command, callback) {
	            callback(null, new XmlElement('ref', {id:'bar'}));
	            
	            event({
	                callId: 'foo',
	                componentId: 'bar',
	                body: new XmlElement('complete', {xmlns: 'urn:xmpp:rayo:ext:1'}).c('hangup').root()
	             });
	         });
         });
      });
      newCall();
   },
   
   'Ping sent': function(test) {

      test.expect(1);
      client.setPingTimeout(100);

      var count = 0;
      process.nextTick(function() {
	      client.transport.send = function(command) {
	    	  if (command.body.getName() == 'bulkPing') {
	    		  count++;
	    	  } else {
	    		  test.fail('Expected ping');
	    	  }
	      }
      });

      newCall();
      
      setTimeout(function() {
    	  test.ok(count >= 8 && count <= 12, 'Bad count: ' + count);
    	  test.done();
      }, 1000);
   },

   'Ping removes non existing calls': function(test) {

      test.expect(13);
      
      client.setPingTimeout(100);
      client.callPingAfter = 50;

      var pings = 0;
      process.nextTick(function() {
	      client.transport.send = function(command, callback) {
	    	  if (pings < 4) {
		    	  test.equals(command.body.getName(), 'bulkPing', 'Expected ping');
		    	  pings++;
		    	  callback(null, new XmlElement('bulkPong').t('foo,bar'));
	    	  }
	      }
      });

      client.on('offer', function(rayoCall) {
    	 rayoCall.on('error', function(error) {
	    	  test.ok(error);	    		 
    	 });
      });
      
      newCall('foo','conn1');
      newCall('bar','conn2');
      newCall('w00t','conn3');
      test.ok(client.tropoCalls['foo']);
      test.ok(client.tropoCalls['bar']);
      test.ok(client.tropoCalls['w00t']);
      
      client.tropoCalls['w00t'].on('error', function(error) {
    	  test.ok(error);
      });
      client.tropoCalls['w00t'].on('end', function(el) {
    	  test.equals(el.getName(), 'end');
    	  test.equals('error', el.children[0].getName());
      });
      
      setTimeout(function() {
          test.equals(client.tropoCalls['woot'], null);
	      test.ok(client.tropoCalls['foo']);
	      test.ok(client.tropoCalls['bar']);
    	  test.done();
      }, 500);
   },
   
   'Ping does not remove any call': function(test) {

      test.expect(7);
      
      client.setPingTimeout(300);
      client.callPingAfter = 50;

      process.nextTick(function() {
	      client.transport.send = function(command, callback) {
	    	  test.equals(command.body.getName(), 'bulkPing', 'Expected ping');
	    	  callback(null, new XmlElement('bulkPong').t('foo,bar,w00t'));
	      }
      });

      newCall('foo','conn1');
      newCall('bar','conn2');
      newCall('w00t','conn3');
      test.ok(client.tropoCalls['foo']);
      test.ok(client.tropoCalls['bar']);
      test.ok(client.tropoCalls['w00t']);
      
      setTimeout(function() {
	      test.ok(client.tropoCalls['foo']);
	      test.ok(client.tropoCalls['bar']);
	      test.ok(client.tropoCalls['w00t']);
    	  test.done();
      }, 500);
   },
   
   'Ping no active calls': function(test) {

      test.expect(16);
      
      client.setPingTimeout(300);
      client.callPingAfter = 50;

      process.nextTick(function() {
	      client.transport.send = function(command, callback) {
	    	  test.equals(command.body.getName(), 'bulkPing', 'Expected ping');
	    	  callback(null, new XmlElement('bulkPong'));
	      }
      });

      client.on('offer', function(rayoCall) {
          rayoCall.on('error', function(error) {
 	    	  test.ok(error);	    		 
     	  });
       });

      newCall('foo','conn1');
      newCall('bar','conn2');
      newCall('w00t','conn3');
      test.ok(client.tropoCalls['foo']);
      test.ok(client.tropoCalls['bar']);
      test.ok(client.tropoCalls['w00t']);
      
      ['foo', 'bar', 'w00t'].forEach(function(it) { 
	      client.tropoCalls[it].on('end', function(el) {
	    	  test.equals(el.getName(), 'end');
	    	  test.equals('error', el.children[0].getName());
	      });            
	      client.tropoCalls[it].on('error', function(error) {
	    	  test.ok(error);
	      });
      });      
      
      setTimeout(function() {
          test.equals(client.tropoCalls['foo'], null);
          test.equals(client.tropoCalls['bar'], null);
          test.equals(client.tropoCalls['woot'], null);
	    	  test.done();
      }, 500);
   },
   
   'Cluster ping': function(test) {

      test.expect(23);
      
      client.setPingTimeout(300);
      client.callPingAfter = 50;

      process.nextTick(function() {
	      client.transport.send = function(command, callback) {
	    	  test.equals(command.body.getName(), 'bulkPing', 'Expected ping');
	    	  if (command.rayoUrl == 'http://server1') {
	    		  callback(null, new XmlElement('bulkPong').t('bar'));
	    	  } else if (command.rayoUrl == 'http://server2') {
	    		  callback(null, new XmlElement('bulkPong').t('oof,rab'));					    		  
	    	  }
	      }
      });
      
      client.on('offer', function(rayoCall) {
          rayoCall.on('error', function(error) {
 	    	  test.ok(error);	    		 
     	  });
       });

      newCall('foo', 'conn1', 'http://server1');
      newCall('bar', 'conn2','http://server1');
      newCall('w00t', 'conn3','http://server1');
      newCall('oof', 'conn4', 'http://server2');
      newCall('rab', 'conn5','http://server2');
      newCall('t00w', 'conn6','http://server2');
      test.ok(client.tropoCalls['foo']);
      test.ok(client.tropoCalls['bar']);
      test.ok(client.tropoCalls['w00t']);
      test.ok(client.tropoCalls['oof']);
      test.ok(client.tropoCalls['rab']);
      test.ok(client.tropoCalls['t00w']);
      
      ['foo', 'w00t', 't00w'].forEach(function(it) { 
	      client.tropoCalls[it].on('end', function(el) {
	    	  test.equals(el.getName(), 'end');
	    	  test.equals('error', el.children[0].getName());
	      });            
	      client.tropoCalls[it].on('error', function(error) {
	    	  test.ok(error);
	      });
      });      

      
      setTimeout(function() {
          test.equals(client.tropoCalls['foo'], null);
          test.ok(client.tropoCalls['bar']);
          test.equals(client.tropoCalls['woot'], null);
          test.ok(client.tropoCalls['oof']);
          test.equals(client.tropoCalls['toow'], null);
          test.ok(client.tropoCalls['rab']);
    	  test.done();
      }, 500);
   },   	
		   
   'Announce without offer causes error': function(test) {

      test.expect(1);

      client.on('error', function(error) {
    	  test.equals(error.message,'Tropo call not found [id=foo]');
    	  test.done();
      });
      
      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('announce').c('joining', {'call-id':'bar2', to:'sip:somone@somewhere'}).up()
       });
   },
   
   'Component event for not existing call causes error': function(test) {

      test.expect(1);

      client.on('error', function(error) {
    	  test.equals(error.message,'Tropo call not found [id=foo]');
    	  test.done();
      });

      event({
          callId: 'foo',
          connectionId: 'bar',
          componentId: 'yay',
          body: new XmlElement('complete', {xmlns: 'urn:xmpp:rayo:ext:1'}).c('hangup').root()
       });
   },
   
   'Warmless call event for not existing call do not causes error': function(test) {

      test.expect(1);

      client.on('error', function(error) {
    	  test.ok(false, ' this is not expected');
      });

      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('unjoined', {xmlns: 'urn:xmpp:rayo:ext:1'}).root()
       });
      
      test.ok(true);
      test.done();
   },
			
   'Subscription data is processed': function(test) {

      test.expect(7);

      client.on('offer', function(call) {
          test.ok(call.subscriber);
          test.ok(call.subscription);
          test.equals(call.subscription.required,'true');
          test.equals(call.subscription.priority,1);
          test.equals(call.subscription.permissions[0],'CALL_RING_LIST');
          test.equals(call.subscription.permissions[1],'CALL_RECORD');
          test.equals(call.subscription.address,'tel:+555');
          test.done();
      });

      newCall();

   },

   'Subscription config is available as JSON object': function(test) {

      test.expect(4);

      client.on('offer', function(call) {
          test.ok(call.subscriber);
          test.ok(call.subscription);
          test.equals(call.subscription.config.foo,'bar');
          test.equals(call.subscription.config.bling,'blaz');
          test.done();
      });

      newCall();
   },

   'Bad Subscription config does not break app': function(test) {

      test.expect(2);

      client.on('offer', function(call) {
          test.ok(call.subscriber);
          test.ok(call.subscription);
          test.done();
      });

      newCall(null,null,null,'{foo:bar}'); // wrong json
   },

   'Call commands get unique sequenced ids': function(test) {

      test.expect(2);

      client.transport.send = function(command ) {
      	  if (command.body.getName() === 'answer') {
    		  test.equals(command.smid, '1', 'Unexpected SDK message id');
    	  }
    	  if (command.body.getName() === 'connect') {
    		  test.equals(command.smid, '2', 'Unexpected SDK message id');
    		  test.done();
    	  }
      };

      client.on('offer', function(call) {
          call.command('answer').send();
          call.command('connect').send();
      });
    	  
      newCall();
   },	   

   'Call components get unique sequenced ids': function(test) {

      test.expect(4);

      client.transport.send = function(command,callback ) {
    	  console.log('Received command ' + command.body);
      	  if (command.body.getName() === 'answer') {
    		  test.equals(command.smid, '1', 'Unexpected SDK message id');
    	  }
    	  if (command.body.getName() === 'output') {
    		  test.equals(command.smid, '2', 'Unexpected SDK message id');
    	  }
    	  if (command.body.getName() === 'input') {
    		  test.equals(command.smid, '3', 'Unexpected SDK message id');
	          callback(null, new XmlElement('ref', {id:'bar'}));
    	  }
    	  if (command.body.getName() === 'pause') {
    		  test.equals(command.smid, '4', 'Unexpected SDK message id');
    		  test.done();
    	  }    	  
      };

      client.on('offer', function(call) {
    	  
          call.command('answer').send();    	  
          call.component('output').c('hello world').up().start();
          call.component('input').c('hello world').up().start(function(err, component) {
              component.command('pause').send();
          });
      });
    	  
      newCall();
   },	   
   
   'Call commands for different calls get different sequenced ids': function(test) {

      test.expect(5);

      client.transport.send = function(command ) {
      	  if (command.body.getName() === 'answer') {
    		  test.equals(command.smid, '1', 'Unexpected SDK message id');
    	  }
    	  if (command.body.getName() === 'connect') {
    		  test.equals(command.smid, '2', 'Unexpected SDK message id');
    	  }
      	  if (command.body.getName() === 'continue') {
    		  test.equals(command.smid, '1', 'Unexpected SDK message id');
    	  }
      	  if (command.body.getName() === 'disconnect') {
    		  test.equals(command.smid, '3', 'Unexpected SDK message id');
    	  }
      	  if (command.body.getName() === 'hold') {
    		  test.equals(command.smid, '2', 'Unexpected SDK message id');
    		  test.done();
    	  }    	  
      };

      client.on('offer', function(call) {
    	  console.log('On offer with id ' + call.callId);
    	  if (call.callId === 'foo') {
    		  call.command('answer').send();
    		  call.command('connect').send();
    		  call.command('disconnect').send();
    	  }
    	  if (call.callId === 'bar') {
    		  call.command('continue').send();
    		  call.command('hold').send();    		  
    	  }
      });
    	  
      newCall('foo','conn1');
      newCall('bar','conn2');
   },	   
   
   'Call commands for different call legs reuse same sequence id': function(test) {

      test.expect(5);

      client.transport.send = function(command ) {
    	  console.log('Sent command ' + command.body);
      	  if (command.body.getName() === 'answer') {
    		  test.equals(command.smid, '1', 'Unexpected SDK message id');
    	  }
    	  if (command.body.getName() === 'connect') {
    		  test.equals(command.smid, '2', 'Unexpected SDK message id');
    	  }
      	  if (command.body.getName() === 'disconnect') {
    		  test.equals(command.smid, '3', 'Unexpected SDK message id');
    	  }
      	  if (command.body.getName() === 'continue') {
    		  test.equals(command.smid, '4', 'Unexpected SDK message id');
    	  }
      	  if (command.body.getName() === 'hold') {
    		  test.equals(command.smid, '5', 'Unexpected SDK message id');
    		  test.done();
    	  }    	  
      };

      client.on('offer', function(call) {
    	  console.log('On offer with connection id ' + call.connectionId + ' and call id ' + call.callId);
		  call.command('answer').send();
		  call.command('connect').send();
		  call.command('disconnect').send();
      });
      client.on('joining', function(call) {
    	  console.log('On joining with connection id ' + call.connectionId + ' and call id ' + call.callId);
		  call.command('continue').send();
		  call.command('hold').send();    		  
      });
    	  
      newCall('foo', 'conn1');
   
	  event({
	      callId: 'foo',
	      connectionId: 'conn2',
	      body: new XmlElement('announce').c('joining', {'call-id':'conn2', to:'sip:somone@somewhere'}).up()
	  });
   },   
   
   'Command error is thrown up': function(test) {

      test.expect(2);

      client.transport.send = function(command, callback) {
                
          var error = new Error("Server error.");
          error.code = 500;
          callback(error, null);
          test.ok(true);
      }      
      
      client.on('offer', function(call) {
         call.command('answer').send(function(error, context) {
             test.ok(error);
             test.equals(error.code, 500);
             test.done();
         });
      });

      newCall();
   },

   'Command 404 cleans connection': function(test) {

      test.expect(8);

      client.ping = function() {
      
          // expected
          test.ok(true);
      };
    
      process.nextTick(function() {
          client.transport.send = function(command, callback) {                    
              var error = new Error("Server error.");
              error.code = 404;
              callback(error, null);
              test.ok(true);
          }
      });      

      client.on('offer', function(call) {
          
         var callId = call.callId;
                           
         test.ok(client.tropoCalls[call.callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections'); 
         
         call.on('end', function(el) {
            // Not expected
            test.ok(false);
         });         
      });
      
      client.on('joining', function(event) {
      
          var conns = client.tropoCalls[event.callId].rayoCalls
          test.equals(Object.keys(conns).length,2, 'Wrong number of connections');

          conns['bar2'].on('end', function(el) {
              test.ok(client.tropoCalls['foo'] != null, 'Call was cleaned up!');
              var conns = Object.keys(client.tropoCalls['foo'].rayoCalls).length;
              test.equals(conns,1, 'Wrong number of connections');
              test.done();
          });
         
          conns['bar2'].command('reject','bar2').send(function(error, context) {
              test.ok(error);
              test.equals(error.code, 404);
          });             
      });
      
      newCall();
      
      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('announce').c('joining', {'call-id':'bar2', to:'sip:somone@somewhere'}).up()
      });
   },         

   'Component command 404 does not clean up connection': function(test) {

      client.ping = function() {
      
          // not expected
          test.ok(false);
      };

      test.expect(6);

      process.nextTick(function() {
          client.transport.send = function(command, callback) {                    
              var error = new Error("Server error.");
              error.code = 404;
              callback(error, null);
              test.ok(true);
          }
      });      

      client.on('offer', function(call) {
          
         var callId = call.callId;
                           
         test.ok(client.tropoCalls[call.callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[call.callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections'); 
         
         call.on('end', function(el) {
            // Not expected
            test.ok(false);
         });         
      });
      
      client.on('joining', function(event) {
      
          var conns = client.tropoCalls[event.callId].rayoCalls
          test.equals(Object.keys(conns).length,2, 'Wrong number of connections');

          conns['bar2'].on('end', function(el) {
              // Not expected
              test.ok(false);
          });
         
          conns['bar2'].component('output').c('audio', {url: 'http://sounds.com/intro.mp3'}).up().start(function(err, component) {
              
              var conns = client.tropoCalls[event.callId].rayoCalls
              test.equals(Object.keys(conns).length,2, 'Wrong number of connections');
              
              test.ok(err);
              test.equals(err.code, 404);
              test.done();
          });             
      });
      
      newCall();
      
      event({
          callId: 'foo',
          connectionId: 'bar',
          body: new XmlElement('announce').c('joining', {'call-id':'bar2', to:'sip:somone@somewhere'}).up()
      });
   },    

   'Command 404 cleans call': function(test) {


      client.ping = function() {
      
          // expected
          test.ok(true);
      };

      test.expect(8);

      process.nextTick(function() {
          client.transport.send = function(command, callback) {
                    
              var error = new Error("Server error.");
              error.code = 404;
              callback(error, null);
              test.ok(true);
          }      
      });
      
      client.on('offer', function(call) {
          
         var callId = call.callId;
         
         test.ok(client.tropoCalls[callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections');
         
         call.command('answer').send(function(error, context) {
             test.ok(error);
             test.equals(error.code, 404);
         });
         
         call.on('end', function(el) {
            test.ok(el);
            process.nextTick(function() {
                // Call will be cleaned up on the next event loop tick
                test.ok(client.tropoCalls[call.callId] == null, 'Call was not cleaned up!');
                test.done();
            });
         });
         
      });
      
      newCall();
   },

   'Component command 404 does not clean up call': function(test) {


      client.ping = function() {
      
          // not expected
          test.ok(false);
      };

      test.expect(5);

      process.nextTick(function() {
          client.transport.send = function(command, callback) {
                    
              var error = new Error("Server error.");
              error.code = 404;
              callback(error, null);
              test.ok(true);
          }      
      });
      
      client.on('offer', function(call) {
          
         var callId = call.callId;
         
         test.ok(client.tropoCalls[callId], 'Call was not created!');
         var conns = Object.keys(client.tropoCalls[callId].rayoCalls).length;
         test.equals(conns,1, 'Wrong number of connections');
         
         call.component('output').c('audio', {url: 'http://sounds.com/intro.mp3'}).up().start(function(err, component) {
             test.ok(err);
             test.equals(err.code, 404);
             
             var conns = Object.keys(client.tropoCalls[callId].rayoCalls).length;
             test.equals(conns,1, 'Wrong number of connections');
             test.done();
         });
         
         call.on('end', function(el) {
             // Not expected
             test.ok(false);
         })         
      });
      
      newCall();
   },   
};

function event(event) {
	parseXml(event.body.toString(), function(err, result) {
		client.transport.emit('callEvent', {
			callId : event.callId,
			connectionId : event.connectionId,
			componentId : event.componentId,
			body : result
		});
	});
};

function newCall(callId, connectionId, rayoUrl, config) {

	var defaultTo = 'tel:+555';
	var defaultFrom = 'tel:+666';
	var defaultConfig = '{"foo":"bar","bling":"blaz"}';
    var body = new XmlElement('offer', {
        to : defaultTo,
        from : defaultFrom,
        'direction' : 'in',
    });
    

	var subscription = body.c('subscription');
	subscription.c('address').t(defaultTo);
	subscription.c('config').t(config ? config : defaultConfig);
	subscription.c('permission', {name:'CALL_RING_LIST'});
	subscription.c('permission', {name: 'CALL_RECORD'});
	subscription.c('priority').t('1');
	subscription.c('required').t('true');

    client.transport.emit('callEvent', {
      callId: callId ? callId : 'foo',
      connectionId: connectionId ? connectionId : 'bar',    		  
      rayoUrl: rayoUrl ? rayoUrl : 'http://localhost:8080/rayo/tropo',
      body: body
    });
};



