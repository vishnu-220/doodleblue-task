= Tropo SDK
:toc: left
:icons: font
:source-highlighter: highlightjs

Tropo, Inc. offers a platform and APIs that enable developers to quickly build and deploy communications applications. By combining voice, video, messaging and real-time presence, our platform accelerates innovation and creates new revenue opportunities for carriers and their partners.

The communications industry is being actively re-invented. Skype and Google Voice are changing user behavior, while services such as Tropo provide developers with a simple API that adds voice and SMS to their existing web applications. At the same time, Apple’s App Store has radically changed how we consume content, applications and services; creating an effective model for connecting developers with billions of potential users. The result has been an explosion of innovation with new value being created for all involved.

Our mission is to empower carriers to realize new services and quickly take them to market. To this end, Project Tropo is being created to bring the innovation and monetization potential of the App Store into the carrier’s core network. 

[source,javascript]
----
require('tropo').on('subscribe', function(event) {
    event.subscriber.on('call:connected', function(event) { 
        var msg = "Hello world";
        console.log(msg);
        event.call.say(msg);
    });
});
----


== Design Goals

Tropo is designed to be a simple alternative to writing IMS applications via low level  SIP APIs. The primary design goals include the following:

* Events. The event-driven nature of Node.js fits very well with telephony and real-time communications. It’s the goal of the Tropo API to model communications as a natural series of real-time events.

* Long running apps. A running Tropo app will receive network events on behalf of a telco user (subscriber). For a given subscriber, events such as incoming calls and changes in location will all be routed to the same instance of the Node.js application therefore allowing the developer to maintain a bit of state and give them the ability to orchestrate multi-modal conversations without the need to external synchronization.

* Calls are key but not the entire story. Unlike Tropo, the Tropo API provides primitives for modeling each leg of a call.. referred to as ‘connections’. Connections will play a larger role as the API evolves as there are ways to combine connections without the need for a call. Imagine an always on video security system or a baby monitor. Those audio/video streams can be captured, combined, mixed, etc. Is this a call? Probably not.

* Idiomatic Node. The Tropo API is packaged as a Node.js module and as such should follow the conventions of the runtime’s native libraries. For example, the use of EventEmitter and standard events such as ‘end’ and ‘error’ are present throughout the API.

== Versioning

*&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;*

Tropo follows the convention established by the Linux kernel and adopted by Node.js: development versions have an *odd* minor number, and stable releases have an *even* minor number.  For example, 0.1.24 is an unstable development version, 0.2.1 is a stable release version.

== API
The following is a complete API reference with code examples to get you started writing Tropo applications.

=== Tropo Object

The primary object in the Tropo SDK, the Tropo Object, offers basic platform version information and EventEmitter facilities for  handling new app subscriptions.

The Tropo Object is a singleton and may be accessed by requiring the `tropo` module.

[source,javascript]
----
var tropo = require('tropo');
----

==== tropo.version
String indicating the Tropo SDK version

==== tropo.on('subscribe', {subscriber})
Indicates that the current app has received a new subscription. The event contains a Subscriber Object
representing a user of the underlying communications network.

==== tropo.on('unsubscribe', {address})
This event indicates that the subscriber with the given address was un-subscribed.

=== Subscriber

Represents a user of the the underlying communications network and is the source of most events.

[source,javascript]
----
var tropo = require('tropo');

tropo.on('subscribe', function(event) {

    var subscriber = event.subscriber;

    subscriber.on('call:incoming', function(event) {
        console.log('Incoming call', event.call);
    });

    subscriber.on('call:outgoing', function(event) {
        console.log('Outgoing call', event.call);
    });

    subscriber.on('call:end', function(event) {
        console.log('Call ended', event.call);
    });

    subscriber.on('call:connected', function(event) {
        console.log('Call connected', event.call);
    }); 
});
----

==== subscriber.id
String representing the unique identifier for the subscriber

==== subscriber.address
String representing the address of the subscriber

==== subscriber.config
String representing the subscriber configuration object

==== subscriber.permissions
Set of subscriber permissions. The possible values are:

* CALL_OFFER:       App may access incoming/outgoing calls
* CALLER_ID:        On an incoming call, App may see the name/address of the caller
* CALL_RECORD:      App may record the call
* CALL_RING_LIST:   App may manipulate the destination on a call
* CALL_WHISPER:     App may play announcement on the call
* CALL_LISTEN:      App may listen some input on the call

==== subscriber.on('call:incoming', {call, subscriber})
Indicated that the subscriber is receiving an incoming call. This event fires before the subscribers' devices start ringing, allowing the app to change the outcome of the call. Emits a Call Object  that may be used to change the outcome of the call by rejecting it or changing the subscriber devices that will ring.
<div class="note">As previously mentioned, this event handler provides the app with an opportunity to change the outcome of the call. If the app does nothing to modify the call (reject, redirect, etc.) the default behavior is to simply ring the subscriber’s phone when returning from this event handler. If the application requires more time or needs to perform an async operation, the Call Object provides an intercept function to do exactly that.</div>

==== subscriber.on('call:outgoing', {call, subscriber})
Indicated that the subscriber is placing an outgoing call. This event fires before the call is sent through the phone network, allowing the app to change the outcome of the call. Emits a Call Object that may be used to change the outcome of the call by rejecting it or by changing the target address.
<div class="note">As previously mentioned, this event handler provides the app with an opportunity to change the outcome of the call. If the app does nothing to modify the call (reject, redirect, etc.), the default behavior is to simply ring the target number when returning from this event handler. If the application requires more time or needs to perform an async operation, the Call Object provides an intercept function to do exactly that.</div>

==== subscriber.on('call:end', {call, subscriber, reason})
A shortcut event indicating that a call just ended. Emits the Call Object of the completed call. Handling this event has the same effect as registering an end listener for all subscriber calls.

==== subscriber.on('call:connected', {call, subscriber, connection})
Shortcut event triggered when either an incoming or outgoing call is answered and the two parties are connected. This event will fire only when the second connection is made. See the Connection API for more details.

=== Call

The Call object models a session among two or more parties.

[source,javascript]
----
subscriber.on('call:incoming', function(event) {

    var call = event.call;

    // Prevent automatic call completion so we can 
    // check a web service to see what to do with the call
    call.autoConnect = false;

    // Check a web service to see what to do
    service.getCurrentMode(function (response) { 
        switch (response.mode) {
            case 'reject':
                call.reject();
                break;
            case 'redirect':
                call.connect(response.redirectTo);
                break;
            default:
                call.connect();
                break;
        }
    });

    call.on('connection:ringing', function(event) { 
        var connection = event.connection;
        console.log('Connection is ringing  address ' + event.address);
    });

    call.on('connection:connected', function(event) { 
        var connection = event.connection;
        console.log('Connected to ' + connection.address);
    });

    call.on('connection:disconnected', function(event) { 
        var connection = event.connection;
        console.log('Connection to ' + connection.address + ' terminated');
    });

    call.on('end', function(event) { 
        console.log('Call ' + call.id + ' terminated');
    });

    call.on('error', function(event) { 
        console.log('Call ' + call.id + ' had error ' + event.error);
    });

});
----

==== call.id
String representing the unique identifier for the call

==== call.direction
String indicating who initiated the call. Values are  ‘in’  for an incoming call and  ‘out’  for outgoing.

==== call.to
String representing the original target address for the call. For incoming calls this will be one of the subscriber’s addresses, and for outgoing calls this will be the original number dialed by the subscriber.

==== call.from
String representing the address that initiated the call. For incoming calls this will be the other party’s address (Caller ID), and for outgoing calls this will be the subscriber's address.

==== call.connections
An Array containing active Connections on the call. A call starts with a single connection (the initiator) and as other endpoints are joined, the connections property will be updated to reflect the addition (See Event: connected).

==== call.autoConnect
Boolean indicating whether the framework should complete the incoming or outgoing call when returning from the  ‘call:incoming’  or  ‘call:outgoing’  event handlers. Setting this property to true before returning from one of those event handlers will result in the call being held until the app decides what to do.  The default for this value is true.
NOTE: It’s critical that the application decide what to do with the call in a timely manner. To enforce this, most Tropo deployments will mark any app taking longer than 5 seconds as unresponsive and that application will no longer be able to participate in the call.

==== call.reject()
Rejects an incoming or outgoing call. This function is only valid when the call is in a pre-connected state (call.connections.length == 1). Calling this function while connected will raise an error.

==== call.connect(addresses)
Accepts a String or an Array of addresses to invite into the call; the first endpoint to answer gets connected and the rest are canceled. This function returns a Connection Object representing the participant that is being invited into the call. When multiple participants are passed as parameters the connection's address property will be updated with attributes of the participant that answers the call.

Adds a new Connection to the call. Connections represent participants of the call that can be a mix of real people or audio/video devices adding media into the call. There are two stages in the call where connections can be added: Offer Phase and Post-Connection Phase. 

The Offer Phase is handled via the  ‘call:incoming’  or  ‘call:outgoing’  event handlers. During this phase, the initiator has dialed a phone number or address and is waiting for the call to connect. In this phase, the application can override the dialed address by calling Call.connect() before returning from the event handler or after performing some async operation if Call.autoConnect is false.

Once the call is established (post-connection phase), invoking this function will simply add to the connection list by inviting those endpoints to participate.

<div class="note">Currently, connections are added by address. Future versions of Tropo may allow combining existing connections by ID or some other means allowing ad-hoc conferences to be created and for two existing calls to be ‘merged’.</div>

==== call.disconnect()
Disconnects the call and all the connections associated with it. 


==== call.record(options)
Begins recording the call.  This function accepts an object whose properties will determine the recording format, various timeouts, etc.

* format _String. The format/encoding to use when recording [‘mp3’, ‘wav’]_
* startBeep _Boolean. Determines if  beep will be played to the use when recording begins_
* maxDuration _Integer. The maximum duration of the recording in seconds_
* initialTimeout _Integer. The amount of silence (in seconds) at the beginning of the recording indicating that the user will not provide input. Defaults to 0 (no timeout)._
* finalTimeout _Integer. The amount of silence (in seconds) indicating that the user has completed providing input. Defaults to 0 (no timeout)._


This function returns a Recording Object that emits lifecycle events and functions for controlling the recording session. (@see Recording Object)


==== call.say(...)

Plays audio to everyone on the call. Arguments are Strings in one of three formats

* Plain Text - Will be spoken as TTS in the default voice/language.
* URL - The data returned by fetching the URL is treated as an audio file. The audio format is discovered via file extension or Content-Type directive.
* SSML - If the String begins with <speak> is will be treated as SSML and delivered as is to the underlying voice engine.

This function returns a Say Object that emits lifecycle events and functions for controlling the announcment. (@see Say Object)


==== call.on('connection:created', {call, subscriber, connection})
Event triggered when an associated connection has been created in response to an invocation of Call.connect() (@see Call.connect())

==== call.on('connection:ringing', {call, subscriber, connection})
Shortcut event triggered when an associated connection has been accepted by the underlying communication network and has begun ringing (@see Connection Event:ringing).

==== call.on('connection:connected', {call, subscriber, connection})
Shortcut event triggered when an associated connection has been successfully established (@see Connection Event:connected).

==== call.on('connection:disconnected', {call, subscriber, connection, reason})
Shortcut event triggered when an associated connection has been successfully established (@see Connection Event:connected).

==== call.on('end', {call, subscriber, reason})
Triggered when the last connection has been disconnected and the call is over.

==== call.on('error', {call, subscriber, error})
Fired when an error occurs on the call.

=== Connection

The Connection object represents a leg of a call.  Once established, it is associated with a single call participant.

[source,javascript]
----
call.on('connection:created', function(event) { 

    var conn = event.connection;

    conn.on('ringing', function(event) {
        console.log('Connection is ringing address ' + event.address);
    });

    conn.on('connected', function(event) {
        console.log('Connection established to ' + event.address);

        // We're connected, now hang up
        conn.disconnect();
    });

    conn.on('disconnected', function(event) {
        console.log('Connection broken to ' + conn.address);
    });

    conn.on('error', function(event) { 
        console.log('Connection had error ' + event.error);
    });     
});
----

==== connection.address
The address for this connection. When the connection object is a result of a ringlist operation ( a connect command with multiple targets ) then this property will stay in undefined state until one of the target participants answers. Then, connection's address property will be set to that participant's address.

==== connection.state 
String representing the current state of the connection. Possible values are: _initial, ringing, connected, disconnected_

==== connection.ringlist
Array containing the remote addresses being invited to join the call

==== connection.disconnect()
Immediately disconnects the connection and removes any reference to it from associate Call.connections

==== connection.say(...)

Plays audio to the call leg. Arguments are Strings in one of three formats:

* Plain Text - Will be spoken as TTS in the default voice/language.
* URL - The data returned by fetching the URL is treated as an audio file. The audio format is discovered via file extension or Content-Type directive.
* SSML - If the String begins with <speak> is will be treated as SSML and delivered as is to the underlying voice engine.

This function returns a Say Object that emits lifecycle events and functions for controlling the announcment. (@see Say Object)

==== connection.listen(..., options)

Starts an IVR operation. This function receives a set of grammar which might be:

* A String with a Voxeo's simple grammar. For example, "[5 DIGITS]"
* A String with an URL pointing to a grammar. For example, "http://grammarserver.com/digits?min=1&amp;max=10"
* A Grammar object with a custom grammar. For example,

[source,xml]
----
<grammar xml:lang="en-US" xmlns="http://www.w3.org/2001/06/grammar" root="colors"> 
    <rule id="colors">
        <one-of>
            <item>red</item>
            <item>blue</item>
            <item>green</item>
        </one-of>
    </rule>  
</grammar>
----

To create a custom Grammar, the Tropo module provides a factory method:

[source,javascript]
----
  var grxml = '<grammar>....</grammar>';
  var grammar = tropo.createGrammar('application/srgs+xml', grxml);
  var result = connection.listen(grammar);
----

This function returns an Listen Object that emits lifecycle events and functions for controlling the IVR operation. (@see Listen Object)

==== connection.on('ringing', {call, subscriber, connection, address})
Triggered when the connection has been accepted and has begun ringing

==== connection.on('connected', {call, subscriber, connection, address})
Triggered when the connection has been successfully established

==== connection.on('disconnected', {call, subscriber, connection, reason})
Triggered when the connection has been disconnected

==== connection.on('error', {call, subscriber, connection, error})
Fired when an error occurs on the connection.


=== Recording

A Recording object models the operation of recording a call or a single connection.

[source,javascript]
----
var recording = call.record({
    format: 'mp3',
    startBeep: true,
    startPaused: false,
    maxDuration: 500,
    initialTimeout: 10,
    finalTimeout: 30
}).
on('start', function(event) {
    console.log('Recording has started');
}).
on('end', function(event) {
    // save recording to a file
    var istream = event.recording.createReadStream();
    var ostream = fs.createWriteStream('/tmp/foo.mp3');
    istream.pipe(ostream);
}).
on('error', function(event) {
    console.log('Error while recording: ' + event.error);
});
----

==== recording.format
Read-Only string representing the format/encoding to use when recording [‘mp3’, ‘wav’]

==== recording.startBeep
Read-Only boolean determines if beep will be played to the user when recording begins

==== recording.maxDuration
Read-only float indicating the maximum duration of the recording in seconds

==== recording.initialTimeout
Read-only float indicating the amount of silence (in seconds) at the beginning of the recording indicating that the user will not provide input. Defaults to 0 (no timeout).

==== recording.finalTimeout
Read-only float indicating the amount of silence (in seconds) indicating that the user has completed providing input. Defaults to 0 (no timeout).

==== recording.duration
Read-only float indicating the duration of the recording in seconds. Defaults to -1 when not set.

==== recording.createReadStream()
Returns a new ReadableStream used to read the recording file.

==== recording.stop()
Immediately stops the recording and will trigger an ‘end’ event.

==== recording.on('start', {call, subscriber, recording})
Triggered when the recording has started. 

==== recording.on('end', {call, subscriber, recording, cause})
Triggered when the recording is complete. The cause attribute indicates what has triggered the end event and it might have the following values:

* success: The recording ended successfully as expected.
* stop: The recording ended because a stop command was received.
* initial_timeout: The recording ended because the initial timeout was exceeded.
* final_timeout: The recording ended because the final timeout was exceeded.
* hangup: The recording ended because the call hung.

==== recording.on('error', {call, subscriber, recording, error})
Triggered if an error occurred during recording.

=== Say

A Say object models the playback of audio to one or more parties on a call.

[source,javascript]
----
var say = call.say({
    “Hello and thanks for calling”,
    “http://server.com/greeting.mp3”
}).
on('end', function(event) {
    console.log('Playback of ' + util.inspect(event.say.tokens) + ' complete');
}).
on('error', function(event) {
    console.log('Error playing audio: ' + event.error);
});
----

==== say.tokens
Array of Strings representing the arguments passed to say()

==== say.stop()
Stops playback of audio

==== say.on('end', {call, subscriber, say, cause})
Triggered when playback of audio is complete. The cause attribute indicates what has triggered the end event and it can have the following values:

* success: The say command ended successfully as expected.
* stop: The say command ended because a stop command was received.
* hangup: The say command ended because the call hung.

==== say.on('error', {call, subscriber, say, error})
Triggered if an error occurred during playback of audio. 


=== Listen

A Listen object models IVR operations on a connection. 

[source,javascript]
----
var listen = connection.listen("[5 DIGITS]", {
    mode: 'dtmf',
    terminator: '=',
    initialTimeout: 3,
    interDigitTimeout: 3
}).

listen.on('end', function(event) {
    if (event.result) {
        console.log('Result: ' + event.result + '. Utterance: ' + event.utterance);
    } else {
        var cause = event.cause;
        if (cause == 'nomatch') {
            console.log("Could not recognize user's input");
        } else if (cause == 'noinput') {
            console.log('The user did not type anything');
        }
    }
});

listen.on('error', function(event) {
    console.log('Error while recording: ' + event.error);
});

----

==== listen.mode
IVR mode. Can be either 'any', 'dmtf' or 'speech'.

==== listen.terminator
Terminator character used on dtmf input. There is no default value.

==== listen.recognizer
Recognizer used for the IVR operation. Default is 'en-us'.

==== listen.initialTimeout
The timeout (in seconds) used to determine that no input will be received. By default, this timeout is disabled. You can set a value to enable it.

==== listen.interDigitTimeout
The timeout (in seconds) used to determine the end of DTMF input. By default, this timeout is disabled. You can set a value to enable it.

==== listen.sensitivity
A float value from 0.0 to 1.0 that determines the noise sensitivity of the media recognizer. The default value is 0.5. Increasing this value will make the interpreter more sensitive to quiet input, while decreasing this value will make it less sensitive to quiet input.

==== listen.minConfidence
A float value from 0.0 to 1.0 that sets the minimum confidence required for the recognizer to recognize the speech based on the grammar. The default value is 0.3. If one were to change this default value to 0.1, then any utterance would be matched, while if it were to be adjusted to 1.0, then virtually every user utterance would be considered a nomatch.

==== listen.maxSilence. 
The timeout (in seconds) used to determine the end of Speech input. By default this timeout is disabled. You can set a value to enable it.    

==== listen.grammars
Array of Strings representing one of the grammars passed to the listen() method.

==== listen.result
The interpretation of the IVR operation. It will only be present if the Ask ends successfully.

==== listen.utterance
An utterance interpretation of the IVR operation. It will only be present if the Ask ends successfully.

==== listen.stop()
Stops the IVR operation.

==== listen.on('end', {call, subscriber, listen, cause})
Triggered upon IVR termination. The cause attribute indicates what has triggered the end event and it can have the following values:

* match: The listen command ended with a match.
* nomatch: The listen command did not match call's input.
* noinput: The listen command ended because there was no input.
* stop: The listen command ended because a stop command was received.
* hangup: The listen command ended because the call hung.
 
==== listen.on('error', {call, subscriber, listen, error})
Triggered if an error occurred while running the IVR opereation.

== Examples

=== say.js

[source,javascript]
----
require('tropo').on('subscribe', function(event) {
    var subscriber = event.subscriber;
    subscriber.on('call:outgoing', function(event) {
      var call = event.call;
      return call.connect([call.to]);
    });
    return subscriber.on('call:connected', function(event) {
      var call = event.call;
      console.log('About to say something!');
      return call.say('Bye bye Kansas!');
    });
  });
----


=== recording.js

[source,javascript]
----
  console.log('Starting Call Recording Example...');

  var tropo = require('tropo');
  var fs = require('fs');

  tropo.on('subscribe', function(event) {
    var subscriber = event.subscriber;
    return subscriber.on('call:connected', function(event) {
      var call = event.call;
      var recording = call.record({
        format: 'wav',
        startBeep: true,
        startPaused: false,
        maxDuration: 500,
        initialTimeout: 10,
        finalTimeout: 30
      });
      recording.on('end', function(event) {
        var recording = event.recording,
            copy, stream;

        console.log('Writing the recording locally...');
        stream = recording.createReadStream();
        copy = fs.createWriteStream('./recording.mp3');
        return stream.pipe(copy);
      });
      recording.on('error', function(error) {
        return console.log('Recording error: ' + error);
      });
      return setTimeout((function() {
        console.log('Stopping the recording');
        return recording.stop();
      }), 8000);
    });
  });
----

=== short_codes.js

[source,javascript]
----
  console.log('Starting Smart Codes Example...');

  var tropo = require('tropo');

  tropo.on('subscribe', function(event) {
    var subscriber = event.subscriber;
    return subscriber.on('call:outgoing', function(event) {
      var call = event.call;
      console.log('Original destination: ' + call.to);
      return call.connect(['sip:alice@voipango.voip']);
    });
  });
----
