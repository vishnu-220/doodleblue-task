var util = require('util'),
    events = require('events'),
    xmpp = require('node-xmpp'),
    uuid = require('node-uuid'),
    http = require('http'),
    request = require('request'),
    log = require('tracer').colorConsole();

var REPO_URL = 'http://tropo.voxeolabs.net/tropo';

var config = {
    jid: "usera@ec2-184-73-85-45.compute-1.amazonaws.com",
    password: "1",
    rayoDomain: "localhost"
};

// Create XMPP connection
var connection = this.connection = new xmpp.Client({
    jid: config.jid,
    password: config.password
});

connection.on('online', function() {
    connection.send(new xmpp.Presence().c('show').t('chat'));
});

var pendingIqs = {};


// >>>>>>>
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var calls = {};

connection.on('stanza', function(stanza) {

    log.debug('XMPP_IN >> ', stanza);

    // Rayo Event
    if (stanza.is('presence') && stanza.children.length > 0 && stanza.children[0].getNS().indexOf('urn:xmpp:rayo') === 0) {

        var from = new xmpp.JID(stanza.from);

        var callId = from.user;
        var componentId = from.resource;
        var body = stanza.children.shift();

        var call = calls[callId];

        if(call === null) {
            // TODO: realy need to know if it's inbound or outbound to know whether to use 'to' or 'from'
            var subscriptionsUrl = REPO_URL + '/runtime/subscriptions?addressValue=' + escape(body.attrs.to);
            request.get({
                url: subscriptionsUrl,
                auth: {user: 'scott', password:'tiger'}}, 
                function(err, res, result){
                    result = JSON.parse(result);
                    var targets = [];
                    result.results.forEach(function(subscription) {
                        var instanceUrl = 'http://' + subscription.instanceHost + ':' + subscription.instancePort + '/';
                        targets.push(instanceUrl);
                    });
                    calls[callId] = {
                        apps: targets
                    };
                    post(targets, callId, componentId, body);
                }
            );            
        }
        else {
            post(call.apps, callId, componentId, body);
        }
        
    }
    // Rayo Command Result
    else if (stanza.is('iq') ) {
        
        var pendingIq = pendingIqs[stanza.attrs.id];

        if(pendingIq !== null) {
            if(stanza.attrs.type == 'error') {
                var errorType = stanza.getChild('error').children[0].getName();
                pendingIq.callback(new Error(errorType), null);
            }
            else {
                pendingIq.callback(null, stanza.children.shift());
            }
        }    
    }

});

function post(apps, callId, componentId, body) {

    console.log('>>', apps, callId, componentId, body);

    var headers = {
        'call-id': callId
    };

    if(componentId !== null) {
        headers['component-id'] = componentId;
    }

    apps.forEach(function(target) {
    	console.log('posting to ', target);
        request.post({
            headers: headers,
            url: target,
            body: body.toString()
            }, function(err, res, body){
            	console.log(arguments);
        });    	
    });
}


// <<<<<<<
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
http.createServer(function (req, res) {

    // Process Request Data
    var data = '';

    req.on('data', function (chunk) {
        data = data + chunk;
    });

    // Forward Request via XMPP
    req.on('end', function() {

        var headers = req.headers,
            target = ''; 

        if(headers['call-id'] !== null) {
            target = headers['call-id'] + '@';
        }

        target = (target + config.rayoDomain);

        if(headers['component-id'] !== null) {
            target = (target + '/' + headers['component-id']);
        }

        var stanza = new xmpp.Element('iq', {
            id: uuid.v4(),
            to: target,
            type: 'set'
        });

        stanza.cnode(ltx.parse(data));

        console.log('<< ' + stanza.toString());

        connection.send(stanza);    

        // Register exsponse Handler
        // TODO: without timeout this is a memory leak
        pendingIqs[stanza.attrs.id] = {
            callback: function(err, result) {
                if(err) {
                    res.writeHead(500, {'Content-Type': 'text/plain'});
                    console.log('>> ' + err.toString());
                    res.end(err.toString());
                }
                else {
                    res.writeHead(200, {'Content-Type': 'application/xml'});
                    console.log('>> ' + result);
                    if(result) {                        
                        res.write(result.toString());
                    }
                    res.end();
                }
            }
        };

    });

}).listen(3333, '0.0.0.0');


