var util = require('util'),
    events = require('events'),
    log = require('winston'),
    utils = require('./utils');

module.exports.listen = function(connection, args) {
	
    if (connection.state !== 'connected') {
        connection.emit('error', new Error('Could not execute listen command. Connection is not connected'));
        return;
    } else {    	
	    var attrs = {};
	    var opts = {};
	    var options = args[args.length-1]; // options if any will be last argument
	    if (typeof options != 'string' && !(options instanceof Grammar)) {
		    opts = options || {};
		    attrs.mode = opts.mode;
		    attrs.terminator = opts.terminator;
		    attrs.recognizer = opts.recognizer;
		    attrs['initial-timeout'] = (opts.initialTimeout * 10000) / 10;
		    attrs['inter-digit-timeout'] = (opts.interDigitTimeout * 10000) / 10;
		    attrs.sensitivity = opts.sensitivity;
		    attrs['min-confidence'] = opts.minConfidence;
		    attrs['max-silence'] = (opts.maxSilence * 10000) / 10;
		    
		    args.pop();
	    }
	    
	    var connectionId = connection._rayo.connectionId;
		var listenElement = connection._rayo.component('input', connectionId, attrs);
	    var listen = new Listen(connection, opts);
	    
	    args.forEach(function(grammar) {
	    	if (typeof grammar == 'string') {
	    		if ((grammar.length > 5) && 
			            (grammar.substring(0,5) == 'http:' || 
			             grammar.substring(0,6) == 'https:')) {
		        	listenElement.c('grammar', {url:grammar});
		        } else {
		    		listenElement.c('grammar', {'content-type':'application/grammar+voxeo'}).t(grammar);
		    	}
	    	} else {
	    		listenElement.c('grammar', {'content-type':grammar.contentType})
	    		    .t('<![CDATA[' + grammar.content + ']]>');
	    	}
	    });
	    listen.grammars = args;
	    
	    listenElement.start(function (error, component) {
			var event = {
			        listen:listen,
			        call:connection.call,
			        subscriber:connection.call.subscriber
			};
	    	
	    	if (error) {
	    		event.error = error;
	    		listen.emit('error', event);
	    	} else {
	    		listen._component = component;
	    		component.on('error', function(error) {
	    			event.error = error;
	    			listen.emit('error', event);
	    		});
	            component.on('complete', function(elem) {
	            	if (elem.getChild('error') !== null) {
	            		event.error = new Error(elem.getChild('error').getText());
	            		listen.emit('error', event);
	            		return;
	            	} else {
		            	event.cause = elem.children[0].getName();
		            	if (elem.getChild('match') !== null) {
		            		//AMECHE-446
		            		var interpretation = elem.getChild('match').getChild('interpretation').getText();
		            		var utterance = elem.getChild('match').getChild('utterance').getText();
		            		event.result = listen.result = interpretation;
		            		event.utterance = listen.utterance = utterance;	            		
		            	}
		            	listen.emit('end', event);	            		
	            	}
	            });
		        listen.emit('start', event);
	    	}
	    });

	    return listen;
	}
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
var Listen = function(connection, opts) {
    this.connection = connection;
    this.grammars = null;
    for (var key in opts) {
        utils.createGetter(this, key, opts);
    }    
};

//Mix in events
util.inherits(Listen, events.EventEmitter);

Listen.prototype.stop = function() {
	if (this._component) {
		this._component.stop();
	}
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function Grammar(contentType, content) {
	
	this.contentType = contentType;
	this.content = content;	
}

module.exports.Grammar = Grammar;