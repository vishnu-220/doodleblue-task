var util = require('util'),
    events = require('events'),
    xmpp = require('node-xmpp'),
    uuid = require('node-uuid');

/*
* Constructs a new Rayo XMPP Transport
* @param {object} config An object containing the configuration for this transport. (see bellow for properties)
* @param {string} config.jid The client's JID
* @param {string} config.password The client's password
* @param {string} config.rayoDomain The domain of the Rayo server (e.g. rayo.org)
* @param {integer} config.commandTimeout Default timeout for client->server commands (in milli)
*/
var Transport = module.exports = function(config) {
   this.pendingIqs = {};
   this.config = config;
};

// Mix in eventing
util.inherits(Transport, events.EventEmitter);

/*
* Puts the transport into service. This is particularly important for transports with active connections
* like XMPP as it allows consumers to register handlers before the transport begins taking requests.
*/
Transport.prototype.start = function() {

   var connection = this.connection = new xmpp.Client({
      jid: this.config.jid,
      password: this.config.password
   });

   connection.on('online', function() {
      connection.send(new xmpp.Presence().c('show').t('chat'));
   });

   var _this = this;

   connection.on('stanza', function(stanza) {

      console.log('XMPP_IN ' + stanza.root().toString());

      // Rayo Event
      if (stanza.is('presence') && stanza.children.length > 0 && stanza.children[0].getNS().indexOf('urn:xmpp:rayo') === 0) {

         var from = new xmpp.JID(stanza.from);

         _this.emit('callEvent', {
            callId: from.user,
            componentId: from.resource,
            body: stanza.children[0]
         });
      }

      // Command Result
      else if (stanza.is('iq') ) {
            
        var pendingIq = _this.pendingIqs[stanza.attrs.id];
        
        if(pendingIq !== null) {
            
            // Cancel the pending IQ timeout
            clearTimeout(pendingIq.timeout);
            
            if(stanza.attrs.type == 'error') {
                var errorType = stanza.getChild('error').children[0].getName();
                pendingIq.callback.call(_this, {code: errorType}, null);
            }
            else {
                pendingIq.callback.call(_this, null, stanza.children.length === 0 ? null : stanza.children[0]);
            }
            
        }
      }


   });

   connection.on('error', function(err) {
      _this.emit('error', err);
   });

};

/*
* Sends the command to the Rayo Server. Primary API for transport clients.
* @param {object} config An object containing the Rayo XML command and other routing information (see bellow)
* @param {object} config.body An ltx object representing the Rayo XML Command
* @param {string} config.callId The ID of the Call to which this command is targeted
* @param {string} config.componentId The ID of the Component to which this command is targeted
* @param {object} callback The function responsible for handling the response from the Rayo Server
*/
Transport.prototype.send = function(command, callback) {

   // Build the target JID
   var target = ''; 

   if(command.callId !== null) {
      target = command.callId + '@';
   }

   target = (target + this.config.rayoDomain);

   if(command.componentId !== null) {
      target = (target + '/' + command.componentId);
   }

   // Build the <iq> envelope
   var stanza = new xmpp.Element('iq', {
      id: uuid.v4(),
      to: target,
      type: 'set'
   });

   // Add the Rayo Command
   stanza.cnode(command.body);

   console.log('XMPP_OUT ' + stanza.root().toString());

   // Send the XMPP request
   this.connection.send(stanza); //, this.config.commandTimeout, callback);

   if(callback !== null) {
      var _this = this;
      var timeout = setTimeout(function() {
          callback.call(_this, new Error("COMMAND_TIMEOUT"), null);
      }, this.config.commandTimeout);

      this.pendingIqs[stanza.attrs.id] = {
          callback: callback,
          timeout: timeout
      };
   }
};