var util = require('util'),
    events = require('events'),
    log = require('winston'),
    http = require('http'),
    url = require('url'),
    utils = require('./utils'),
    stream = require('stream'),
	fs = require('fs');

module.exports.record = function(call, options) {

    if (!(call.connected)) {
        call.emit('error', new Error('Could not execute record command. Call ' + 
                call.id + ' is not connected'));
        return;
    } else {
    	return startRecord({call:call, options:options});    		
	}
};

module.exports.connectionRecord = function(connection, options) {

    if (connection.state !== 'connected') {
        connection.emit('error', new Error('Could not execute record command. Connection ' + connection.id + ' is not established yet.' + connection.state));
        return;
    } else {
        // duplex default to false on connection recording
    	if (!options) {
    		options = {};
    	}    	
        if (!('duplex' in options)) {
        	options.duplex = false;
        }
	    return startRecord({call:connection.call,connection:connection, options:options});
	}
};

function startRecord(record) {
	
    var opts = record.options || {};
    var attrs = {};
    var call = record.call;
    var connection = record.connection;
    
    // duplex default to true when not set
    if (!('duplex' in opts)) {
    	opts.duplex = true;
    }
    
    attrs.to = opts.to;
    attrs.format = opts.format;
    attrs['initial-timeout'] = (opts.initialTimeout * 10000) / 10;
    attrs['final-timeout'] = (opts.finalTimeout * 10000) / 10;
    attrs['max-duration'] = (opts.maxDuration * 10000) / 10;
    attrs['start-beep'] = opts.startBeep;
    attrs['stop-beep'] = opts.stopBeep;
    attrs.duplex = ''+opts.duplex;
    attrs.expireAfter = opts.expireAfter;
    attrs.expireAfterFetch = opts.expireAfterFetch;
    
    var connectionId = connection ? connection._rayo.connectionId : null;
    var rayo = connection ? connection._rayo : call.rayoCall;    
    
    var recordElement = rayo.component('record', connectionId, attrs);
    var recording = new Recording(call, connection, opts);
        
    recordElement.start(function(error, component) { 
		var event = {
		        recording:recording,
		        call:call,
		        connection: connection,
		        subscriber:call.subscriber,
		        duration:-1
		};	    	
    	
        if (!error) {
        	component.on('error', function(error) {
        		log.debug('Error on recording: ' + util.inspect(error));
        		event.error = error;
        		recording.emit('error', event);
        	});
            component.on('complete', function(elem) { 
            	recording.duration = -1;
                if (elem.getChild('timeout') || elem.getChild('final_timeout')) {
                	event.cause = 'final_timeout';
                	event.error = new Error('Timeout while executing record command');
                	recording.emit('error', event);
                } else if (elem.getChild('error')) {
                	event.cause = 'error';
                    event.error = new Error('Unexpected error : ' + elem.getChildren('error')[0].getText());
                    recording.emit('error', event);
                } else {
                    if (elem.getChild('initial_timeout')) {
                        event.cause = 'initial_timeout';
                	} else if (elem.getChild('stop')) {
                		event.cause = 'stop';
                	} else if (elem.getChild('max_duration')) {
                		event.cause = 'max_duration';
                	} else if (elem.getChild('hangup')) {
                		event.cause = 'hangup';
                	} else {
                		event.cause = 'success';
                	}
                	var recElement = elem.getChildren('recording')[0];
                	event.duration = parseFloat(recElement.attrs.duration/1000);
                	recording.size = recElement.attrs.size ? parseInt(recElement.attrs.size) : undefined;
                	recording.duration = event.duration;
                	if (recElement.attrs.uri) {
	                	recording.serverFilename = recElement.attrs.serverFilename;
		                var uri = url.parse(recElement.attrs.uri);	
		                recording.uri = uri;
		                recording.createReadStream =  function() {
						    var recordingStream = new RecordingStream();
						    var headers = {};
						    headers['call-id'] = recording.call.id;
						    headers['connection-id'] = recording.connection ? recording.connection._rayo.callId : null;
						    headers['auth-token'] = recording.call.authToken;
						    var options = {
						    	hostname: uri.hostname,
						    	port: uri.port,
						    	path: uri.path,
						    	headers: headers
						    };
						    log.debug('Fetching recording with options: ' + util.inspect(options));
						    http.get(options, function(res) {
						    	if (res.statusCode != '200') {
						    		log.debug('Emitting error on recording');
						    		recording.emit('error', new Error('Could not fetch recording. Error code: ' + res.statusCode));
						    	} else {
						    		res.pipe(recordingStream).on('end', function() {
						    			log.debug('Is expire after fetch? ' + opts.expireAfterFetch);
						    			if (opts.expireAfterFetch) {
						    				options.path = uri.path + "/complete";
						    				http.get(options, function(res) {
										    	if (res.statusCode != '200') {
										    		recording.emit('error', new Error('Could not delete server side recording file. Error code: ' + res.statusCode));
										    	} else {
										    		log.debug('Server side recording deleted successfully.');
										    	}						    					
						    				});
						    			}
						    		});
						    	}
	                        });
	                        return recordingStream;
		                };
                	}
	                log.debug('Emitting end');
	                recording.emit('end', event);
	            }
            });
    	    recording.stop = function() {
	            component.stop();
	        };
	        recording.pause = function() {
	            component.command('pause').send();
	        };
	        recording.resume = function() {
	            component.command('resume').send();
	        };
	        recording.emit('start', event);
        } else {
        	event.error = error;
    		log.debug('Error on recording: ' + util.inspect(error));	        	
            recording.emit('error', event);
        }
    });
    return recording;
}	

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
var Recording = function(call, connection, opts) {
	
    this.call = call;
    this.connection = connection;
    for (var key in opts) {
        utils.createGetter(this, key, opts);
    }
};

// Mix in events
util.inherits(Recording, events.EventEmitter);

// delete a recording
Recording.prototype.delete = function(callback) {
	
	var _this = this;
	if (this.uri) {
	    var headers = {};
	    headers['call-id'] = this.call.id;
	    headers['connection-id'] = this.connection ? this.connection._rayo.connectionId : null;
	    headers['auth-token'] = this.call.authToken;
	    
	    var options = {
		    	hostname: this.uri.hostname,
		    	port: this.uri.port,
		    	path: this.uri.path,
		    	headers: headers,
		    	method: 'DELETE'
		};
	    log.debug('Deleting recording with options: ' + util.inspect(options));
		var req = http.request(options, function(res) {
	    	if (res.statusCode != '200') {
	    		_this.emit('error', new Error('Could not delete server side recording file. Error code: ' + res.statusCode));
	    	} else {
	    		log.debug('Server side recording deleted successfully.');
	    		if (callback) {
	    			callback(res);
	    		}
	    	}						    					
		});
		req.end();
	} else {
		this.emit('error', new Error('Cannot delete. Recording is not complete yet.'));
	}
};

//Set both readable and writable in constructor.
var RecordingStream = function () {
	PassThrough.call(this, {});
};

var PassThrough = stream.PassThrough || require('readable-stream').PassThrough;

// Inherit from Duplex or readable-stream when Duplex does not exist ( node < 0.10 )
require('util').inherits(RecordingStream, PassThrough);
