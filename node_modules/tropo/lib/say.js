var util = require('util'),
    events = require('events'),
    log = require('winston');


var Say = function(call, connection) {
    this.call = call;
    this.connection = connection;
    this.tokens = null;
};

module.exports.Say = Say;

//Mix in events
util.inherits(Say, events.EventEmitter);

Say.prototype.stop = function() {
	if (this._component) {
		this._component.stop();
	}
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
module.exports.say = function(call, args) {

	var result;
	if (call.connections.length == 1 && call.connected) {
	    result = startSay({call:call, connection:call.connections[0],
	                args:args});
	} else {
	    result = startSay({call:call, args:args});
	}
	return result;
};

module.exports.connectionSay = function(connection, args) {

	return startSay({call:connection.call,connection:connection, args:args});
};


function startSay(say) {

	var connection = say.connection ? say.connection : null;
	var call = say.call;
	var args = say.args;
	
    var connectionId = connection !== null ? connection._rayo.connectionId : null;
    var rayo = connection !== null ? connection._rayo : call.rayoCall;

    // Find arguments
    var attrs = {};
    if (args) {
	    args.forEach(function(token) {
	    	if (typeof token === 'object') {
	    		// config object
	    	    attrs.repeat = token.repeat;
	    	    if (typeof token.ifBusy !== 'undefined') {
                    if (['queue', 'stop', 'error'].indexOf(token.ifBusy.toLowerCase()) >= 0) { 
                        attrs['if-busy'] = token.ifBusy;
                    } else {
                        throw new Error('Invalid value for ifBusy: ' + token.ifBusy + '. Should be one of: queue|stop|error');
                    }
                }
	    	    attrs.voice = token.voice;
	    	}
	    });
	}
	var outputElement = rayo.component('output', connectionId, attrs);
	// Parse tokens
	if (args) {
	    args.forEach(function(token) {
	    	if (typeof token === 'string') {
		        if ((token.length > 5) && 
		            (token.substring(0,5) == 'http:' || 
		             token.substring(0,6) == 'https:')) {
		    		outputElement.c('audio',{src:token});
		        } else {
		    		if (token.substring(0,6) == '<speak') {
		    			outputElement.t(token);
		    		} else {
		    			outputElement.c('p').t(token);    			
		    		}
		    	}
	    	}
	    });
	}
	var result = new Say(call, connection);
	
	result.tokens = args;
    outputElement.start(function (error, component) { 
		var _call = call !== null ? call : connection.call;
		var event = {
		        say:result,
		        call:_call,
		        subscriber:_call.subscriber
		};
    	if (error) {
    		event.error = error;
    		result.emit('error', event);
    	} else {
    		result._component = component;
    		component.on('error', function(error) {
    			event.error = error;
    			result.emit('error', event);
    		});
    		component.on('complete', function(elem) { 
    		    if (elem.getChild('error') !== null) {
    		    	event.error = new Error(elem.getChild('error').getText());
    		    	event.cause = 'error';
        		    result.emit('error', event);
    		    } else {
	            	event.cause = elem.children[0].getName();
    			    result.emit('end', event);
    		    }
    		});
	        result.emit('start', event);
    	}
    });
    return result;
}

