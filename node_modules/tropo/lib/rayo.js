/*global module*/

var RAYO_NAMESPACE = 'urn:xmpp:rayo:1';
var RAYO_NAMESPACE_BASE = 'urn:xmpp:rayo';
var RAYO_VERSION = '1';

var log = require('winston');
var util = require('util');
var events = require('events');
var util = require('util');
var utils = require('./utils');

var XmlElement = utils.XmlElement;

var Rayo = module.exports = function (config, transport) {

    this.rayoCalls = {};
    this.tropoCalls = {};
    this.pingTimeoutId = null;
    this.callPingInterval = config.callPingInterval ? config.callPingInterval : 1800000;
    this.callPingAfter = config.callPingAfter ? config.callPingAfter : 1800000;
    
    // Sets some limits to prevent ping flooding a Tropo AS
    this.minDirectPingInterval = config.minDirectPingInterval ? config.minDirectPingInterval : 30000;
    this.latestDirectPing = 0;

    this.transport = transport;

    var _this = this;

    transport.on('callEvent', function (event) {
        
    	var el = event.body;
    	el.headers = extractHeadersFromBody(el);
    	
    	// New Call
    	var rayoCall = null;
        if (el.getName() == 'offer') {
            _this.tropoCalls[event.callId] = new TropoCall(event.callId, event.rayoUrl);
            rayoCall = _this.registerCall(event.callId, event.connectionId, el);
            rayoCall.rayoUrl = event.rayoUrl;
            rayoCall.authToken = event.authToken;      
            var subscription = el.getChild('subscription');
            if (subscription !== null) {
	            var address = subscription.getChild('address');
	            rayoCall.subscriber = address.getText();
	            rayoCall.subscription = new Subscription(subscription);
            } else {
            	rayoCall.subscriber = event.subscriber;
            }
            _this.emit('offer', rayoCall);
            return;
        }

        // If not a new Tropo call then lookup the call in the registry
        var tropoCall = _this.tropoCalls[event.callId];
        if (!tropoCall) {
        	if (event.componentId || el.getName() == 'announce') {
        		// Error. An incoming event for a component or announcement comes in but the call does not exist any more
        		_this.emit('error', new Error("Tropo call not found [id=" + event.callId + "]"));
        	} else {
        		// We will just debug call events for unexisting calls. Not as severe as above.
        		log.debug('Received event ' + el.getName() + ' for a call id that does not exist any more: ' + event.callId);
        	}
            return;
        }

        // Server-Created call being joined to existing call
        if (el.getName() == 'announce') {
            var joining = el.children[0];
            var connectionId = joining.attrs['call-id'];
            var callId = event.callId;
            var peerAddress = joining.attrs.to;
           
            call = _this.registerCall(callId, connectionId, null);
            // the new call will share the same token and rayo URL with the original offer call
            call.authToken = _this.rayoCalls[event.connectionId].authToken;
            call.rayoUrl = _this.rayoCalls[event.connectionId].rayoUrl;
            _this.emit('joining', call, peerAddress);
            return;
        }
                
        if (!event.componentId) {
        	if (!event.connectionId) {
        		log.debug('Received global event ' + el.getName() + ' on Ameche call ' + event.callId);
            	if (el.getName() == 'end') {
            		// Received a global end. This should dispose all Ameche Call resources including 
            		// any virtual conference references
            		log.debug('Received an Ameche Call end event for ' + event.callId + '. Unregistering active connections.');
            		_this.disposeCall(event.callId, el);
            	}
            	return;
        	}
            rayoCall = tropoCall.rayoCalls[event.connectionId];
            if (rayoCall) {
	            if (el.getName() == 'end') {
	                _this.unregisterCallLeg(event.callId, event.connectionId, el);
	            } else {
	                log.debug('Emitting event ' + el.getName() + ' on rayo call: ' + rayoCall.connectionId);
                    rayoCall.emit(el.getName(), el);
                }
	            
            } else {
            	//_this.emit('error', new Error('Received an event for an unknown connection id: ' + event.connectionId + '. Call id: ' + event.callId));
            	// This was way too much erroring
            	log.debug('Received an event for an unknown connection id: ' + event.connectionId + '. Call id: ' + event.callId);
            	return;
            }
        } else {
        	//log.debug('Got verb event for component id: ' + event.componentId);
        	var source = tropoCall;
            var component = source.components[event.componentId];
            if (!component) {                
            	source = tropoCall.rayoCalls[event.connectionId];
            	if (source) {
            		component = source.components[event.componentId];
            	}
            }
            if (!component) {
            	_this.emit('error', 'Could not find Tropo Call or connection for call id ' + event.callId + ' and connection id ' + event.connectionId);
            	return;
            } else {
                //log.debug('Found component ' + component + ' for id ' + event.componentId + ' on call ' + call.callId + ' and connection ' + call.connectionId + '. Components: ' + util.inspect(call.components));
                if (el.getName() == 'complete') {
                	//log.debug('Received complete event. Disposing verb with id ' + event.componentId);
                	delete source.components[event.componentId];
                }
                component.emit(el.getName(), el);
            }
        }
    });

    transport.on('subscribe', function (event) {
        // log.info('transport.on.subscribe');
        _this.emit('subscribe', event);
    });

    transport.on('unsubscribe', function (event) {
        // log.info('transport.on.unsubscribe');
        _this.emit('unsubscribe', event);
    });

    // Bubble the error up to the rayo client
    transport.on('error', function (err) {
        _this.emit('error', err);
    });

    log.debug("Scheduling Tropo's ping task. Ping interval: " + this.callPingInterval);
    this.pingTimeoutId = setTimeout(function () {
        _this.ping();
    }, this.callPingInterval);

    // Now that we have our handlers registered we can start the transport
    transport.start();

};

// Mix in eventing
util.inherits(Rayo, events.EventEmitter);

function extractHeadersFromBody(el) {
	
	var headers = {};
	var elements = el.getChildren("header");
    elements.forEach(function (element) {
    	headers[element.attrs.name] = element.attrs.value;
    });
    
    return headers;
}

Rayo.prototype.registerTropoHandler = function(call) {
    
    var tropoCall = this.tropoCalls[call.id];
    if (tropoCall) {
        tropoCall.on('error', function(event) {
            call.emit('error', event);
        });
    } else {
        log.error("Could not register tropo handler. Call with id " + call.id + " does not exist");
    }
}

Rayo.prototype.setPingTimeout = function(timeout) {
	
	var _this = this;
    if (this.pingTimeoutId) {
    	log.debug('Clearing existing ping task');
        clearTimeout(this.pingTimeoutId);
    }
    this.callPingInterval = timeout;
    log.debug('Scheduling new ping task to run in ' + timeout + ' milliseconds');
    this.pingTimeoutId = setTimeout(function () {
    	log.debug('Pinging');
        _this.ping();
    }, timeout);
};

/* 
 * Register an active call
 * @param {string} callId The active call's ID
 * @param {object} offer The ltx <offer/> element
 */
Rayo.prototype.registerCall = function (callId, connectionId, offer) {
	
    var rayoCall = this.rayoCalls[connectionId] = new Call(callId, connectionId, offer, this);
    var tropoCall = this.tropoCalls[callId];
    tropoCall.rayoCalls[connectionId] = rayoCall;
    return rayoCall;
};

/* 
 * Disposes the rayo client
 */
Rayo.prototype.dispose = function () {

    log.debug('Disposing rayo client');
    if (this.pingTimeoutId) {
        clearTimeout(this.pingTimeoutId);
    }
    this.rayoCalls = {};
    this.tropoCalls = {};
    delete this.transport;
};

Rayo.prototype.disposeCall = function(callId, el) {

    var _this = this;
    if (callId) {
        var tropoCall = this.tropoCalls[callId];
        // Check to clean any active dispose timeout 
        if (tropoCall.endTimeoutId) {
            clearTimeout(tropoCall.endTimeoutId);
            tropoCall.endTimeoutId = null;
            tropoCall.endTimeoutsProcessed++;
        }        
        var pendingComponents = Object.keys(tropoCall.components).length;        
        if (pendingComponents === 0) {
            log.debug("There is no pending components for call id " + callId + ". Disposing call");
            doDispose(_this, tropoCall, el);
        } else {
            log.debug("There is " + pendingComponents + " waiting to be disposed on call id " + callId + ". Delaying global call dispose");
            tropoCall.endTimeoutId = setTimeout(function () {
                if (tropoCall.endTimeoutsProcessed < 20) { 
                    _this.disposeCall(callId, el);
                } else {
                    log.debug("Maximum number of retries reached for call id " + callId + ". Disposing call");
                    doDispose(_this, tropoCall, el);
                }
            }, 200);        
        }
    }
};

function doDispose(rayo, tropoCall, el) {

    var callId = tropoCall.callId;
    rayo.unregisterAllCallLegs(callId, el);
    var reason = null;
    if (typeof(el) !== 'undefined') {
        if (el.children && el.children.length) {
            reason = el.children[0].getName();
        }
    }
    log.debug('Deleting tropoCalls object for ' + callId);
    delete rayo.tropoCalls[callId];
    log.debug('Tropo call for ' + callId + ' is ' + rayo.tropoCalls[callId]);
    if (rayo.transport && rayo.transport.tropoMids) {
        delete rayo.transport.tropoMids[callId];
    }
    log.debug('Emitting call with id ' + callId + ' and reason ' + reason);
    rayo.emit('end', {id: callId, reason: reason});
}

Rayo.prototype.unregisterAllCallLegs = function (callId, el) {

    var _this = this;
    if (callId) {
        log.debug('Unregistering all call legs on Tropo Call: ' + callId);
        var tropoCall = _this.tropoCalls[callId];
        if (tropoCall) {
            var connectionIds = Object.keys(tropoCall.rayoCalls);                   
            for (var i=0; i< connectionIds.length; i++) {
                var connectionId = connectionIds[i];
                var rayoCall = tropoCall.rayoCalls[connectionId];
                _this.unregisterCallLeg(callId, connectionId, el);
            }
        }
    }
};

Rayo.prototype.unregisterCallLeg = function (callId, connectionId, el) {
	
	if (callId && connectionId) {
	    var rayoCall = this.rayoCalls[connectionId];
	    
        delete this.rayoCalls[connectionId];
        
        var tropoCall = this.tropoCalls[callId];
        delete tropoCall.rayoCalls[connectionId];
        var size = Object.keys(tropoCall.rayoCalls).length;
        log.debug('Removed connection ' + connectionId + '. Tropo call id ' + callId + ' has got ' + size + ' active connections.');
        if (typeof(el) !== 'undefined') {
            log.debug('Emitting event ' + el.getName() + ' on Tropo connection: ' + connectionId + ' with no reason.');
            rayoCall.emit(el.getName(), el);
        }                
    }
};

Rayo.prototype.unregisterCall = function (callId) {
	
    var tropoCall = this.tropoCalls[callId];
    if (typeof tropoCall !== 'undefined') {
        tropoCall.length = 0;
	    delete this.tropoCalls[callId];
        log.debug('Removed Tropo call id ' + callId + '.');
    } else {
    	log.debug('Call with id ' + callId + ' has been already removed from calls registry');
    }
};

Rayo.prototype.ping = function () {

	log.debug('Starting ping process. Ping interval: ' + this.callPingInterval);
    var _this = this;
    var callids = Object.keys(_this.tropoCalls);
    
    if (callids.length > 0) {
    	var rayoMap = {};
        // Need to group them by rayoUrl to support cluster pings
    	for (var i=0; i< callids.length; i++) {
    		var call = _this.tropoCalls[callids[i]];
    		var nodeCalls = rayoMap[call.rayoUrl];
    		if (!nodeCalls) {
    			nodeCalls = [];
    			rayoMap[call.rayoUrl] = nodeCalls;
    		}
    		nodeCalls.push(call.callId);
    	}
    	var urls = Object.keys(rayoMap);
    	for (var j=0; j<urls.length; j++) {
    		pingCalls(rayoMap[urls[j]], _this);
    	}
    } else {
    	log.debug('Skipping ping. No active calls');
    }
    this.pingTimeoutId = setTimeout(function () {
    	if (_this !== undefined) {
    		_this.ping();
    	}
    }, _this.callPingInterval);
};

function getAndIncreaseSmid(rayo, callId) {
	
	var tropoCall = rayo.tropoCalls[callId];
    if (typeof tropoCall !== 'undefined') {
    	var smid = tropoCall.smid + 1;
    	tropoCall.smid = smid;
    	return smid;
    } else {
    	log.debug('Call with id ' + callId + ' does not exist');
    }
}


// Ping calls still goes on behalf of a concrete call to enforce some degree of authentication
function pingCalls(ids, rayo) {

	log.debug('Sending bulk ping request. ids: ' + util.inspect(ids));
	var call = rayo.tropoCalls[ids[0]];
	log.debug('Tropo call: ' + util.inspect(call));
	var connectionId = Object.keys(call.rayoCalls)[0];

	call.rayoCalls[connectionId].bulkPing(function (error, response) {
    	var start = new Date().getTime();
        if (error) {
        	log.error("Received error " + error.code + " while pinging calls. Skipping.");
        } else {
        	var pong = response.children[0];
        	var callIds = [];
        	if (pong) {
        		callIds = pong.split(",");
        	}
	    	for (var i=0; i < ids.length; i++) {
	    		var key = ids[i];
	    		var found = false;
	    		for (var j=0; j < callIds.length; j++) {
		    		if (key == callIds[j]) {
		    			found = true;
		    			break;
		    		}
	    		}
    	    	if (!found) {
                    log.debug('Tropo Call [' + key + '] is not registered at rayo server. Unregistering call.');
                    var tropoCall = rayo.tropoCalls[key];    
                    if (tropoCall) {
                    	var errorMessage = 'Tropo Call [' + key + '] has been disposed on the Ameche Server';
                    	try {
                    	   tropoCall.emit('error', new Error(errorMessage));
                    	} catch (err) {
                    	   log.debug("Could not emit ping error into call: " + tropoCall.callId);
                    	}
                    	
                    	var el = new XmlElement('end').c('error').t(errorMessage).root();
                        rayo.disposeCall(tropoCall.callId, el);                    	
                    	tropoCall.emit('end', el);
                    }
                    rayo.unregisterCall(key);        	    		
    	    	}
            }
            var end = new Date().getTime();
            log.debug('Bulk ping finished in ' + (end - start) + ' milliseconds.');
        }
    });
}


/*
 * Send a Rayo command to an active component (or call if componentId is null)
 * @param {object} An object containing the callId/mixerName and the ltx command body
 * @param {object} The context in which the callback should be invoked
 * @param {function} callback The function to fire with the results of the command execution
 */
Rayo.prototype.send = function (command, context, callback) {
    if (this.transport) {
        var _this = this;
        process.nextTick(function () {
            if (_this.transport) {
                _this.transport.send(command, function (error, result) {
                    if (error) {                                       	
                        if (callback) {
                            callback.call(context, error);
                        } else {
                            _this.emit('error', error);
                        }
                        if (command.body.getName() == 'connect') {
                            // always clean up call in case of connect error
                            log.debug('Server returned error ' + error.code + ' for connect request. Disposing connection with id ' + command.connectionId + ' in Tropo call ' + command.callId);
                            _this.unregisterCall(command.callId, command.connectionId);
                                                        
                        } else if (error.code == 404 && 'bulkPing' !== command.body.getName()) {                        
                            // TROPO-7138: Tear down resources on 404s
                            log.debug("Received 404. Call id: " + command.callId + ". Connection id: " + 
                                command.connectionId + ". Component id: " + command.componentId); 
                            if (command.callId && !command.isComponentCommand) {
                                // Force a ping
                                var currentTime = new Date().getTime();
                                if (currentTime - _this.latestDirectPing > _this.minDirectPingInterval) {
                                    log.debug("Scheduling a direct ping to clean up resources in Tropo AS");
                                    _this.latestDirectPing = currentTime;
                                    _this.ping();
                                } else {
                                    var ellapsed = (currentTime - _this.latestDirectPing);
                                    log.debug("Already sent a ping " + ellapsed + " milliseconds ago. Skipping this one."); 
                                }
                                 
                                var el = new XmlElement('end').c('error').t("Call not found").root();
                                if (command.connectionId) {
                                    _this.unregisterCallLeg(command.callId, command.connectionId, el);
                                } else {
                                    _this.disposeCall(command.callId, el);
                                }
                            }                
                        }   
                    } else {
                        if (callback) {
                            callback.call(context, null, result);
                        }
                    }
                });
            } else {
                log.debug('Skipping sending command ' + command.name + '. Transport has been disposed.');
            }
        });
    }
};

Rayo.prototype.command = function (name, attr) {

    // Init attributes is they are null
    var _attr = attr ? attr : {};

    // Add Rayo namespace
    _attr.xmlns = RAYO_NAMESPACE;

    // Create XML
    var command = new XmlElement(name, _attr);

    // Add the send() method
    var _this = this;
    command.send = function (callback) {
        _this.send({
            body: command
        }, _this, callback);
    };

    return command;
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var TropoCall = function (callId, rayoUrl, rayoClient) {
	
    this.callId = callId;
    this.client = rayoClient;
    this.rayoUrl = rayoUrl;
    this.components = {};
    this.rayoCalls = {};
    this.smid = 0; // This id uniquely identifies messages sent to AS
    this.endTimeoutsProcessed = 0; // Used to handle global end events when there is need to wait or out of order messages 
};

// Mix in eventing
util.inherits(TropoCall, events.EventEmitter);

TropoCall.prototype.addComponent = function (component) {

    this.components[component.id] = component;
};

TropoCall.prototype.removeComponent = function (id) {

    delete this.components[id];
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var Call = function (callId, connectionId, offer, rayoClient) {
	
    this.callId = callId;
    this.connectionId = connectionId;
    this.offer = offer;
    this.client = rayoClient;
    this.components = {};
    this.offerTime = Date.now();
};

// Mix in eventing
util.inherits(Call, events.EventEmitter);

/*
 * The hotnes! Creates an ltx element with the given name but patches the object with a send()
 * method allowing the command to be sent as the last method in the builder pattern.
 */
Call.prototype.command = function (name, connectionId, attr) {

    // Init attributes is they are null
    var _attr = attr ? attr : {};

    // Add Rayo namespace
    _attr.xmlns = RAYO_NAMESPACE;

    // Create XML
    var command = new XmlElement(name, _attr);

    // Add the send() method
    var _this = this;
    var smid = getAndIncreaseSmid(_this.client, _this.callId);

    command.send = function (callback) {
        _this.client.send({
        	smid: smid,
            callId: _this.callId,
            connectionId: connectionId,
            rayoUrl: _this.rayoUrl,
            authToken: _this.authToken,
            body: command
        }, _this, callback);
    };

    return command;
};

Call.prototype.bulkPing = function (callback) {

    var command = this.command('bulkPing');
    command.send(function (error, result) {
        callback(error, result);
    });
};

Call.prototype.connect = function (targets, attr, callback) {

    var _this = this;
    var headers = {};
    if (typeof attr !== 'undefined') {
	    if (typeof attr.headers !== 'undefined') {
	    	headers = attr.headers;
	    	delete attr.headers;
	    }
    }
    
    var command = this.command('connect', null, attr);
    targets.forEach(function (target) {
    	if (typeof target === 'string') {
        	command.c('target').t(target).up();
    	} else {
        	command.c('target').t(target.toURI()).up();
    	}
    });
    
    for (var key in headers) {
    	command.c('header', {name: key, value: headers[key]}).up();
  	}
    if (!callback) {
        callback = function (error, result) {
            if (error) {
                log.warn("Error sending connect request", { error: error });
            }
        };
    }

    command.send(callback);
};

Call.prototype.component = function (name, connectionId, attr) {

    var _this = this;
    // Init attributes is they are null
    var _attr = attr ? attr : {};

    // Add Rayo namespace
    _attr.xmlns = RAYO_NAMESPACE_BASE + ':' + name + ':' + RAYO_VERSION;

    // Create XML
    var command = new XmlElement(name, _attr);

    var smid = getAndIncreaseSmid(_this.client, _this.callId);
    
    // Add the start() method
    command.start = function (callback) {

        // Send the command to start the component
        _this.client.send({
                callId: _this.callId,
                smid: smid,
                connectionId: connectionId,                
                rayoUrl: _this.rayoUrl,
                authToken: _this.authToken,
                isComponentCommand: true,
                body: command
            }, _this,
            // Watch for the response.
            //  If error then report it
            //  Otherwise register the component in the call's registry
            function (error, el) {
                //log.debug('Received component response');
                if (error) {
                    if (callback) callback.call(_this, error);
                } else if (el && el.getName() == 'ref') {
                    var componentId = el.attrs.id;
                    if (!_this.components[componentId]) {
                        var component = new Component(componentId, connectionId, command, _this, _this.client);
                        //log.debug('Registered component ' + component.id + ' with call ' + _this.callId + " and connection " + _this.connectionId);
                        
                        if (connectionId) {
                        	_this.components[component.id] = component;
                        } else {
                        	var tropoCall = _this.client.tropoCalls[_this.callId];
                        	tropoCall.addComponent(component);
                        }
                        
                        if (callback) callback.call(_this, null, component);
                    } else {
                        log.debug("Ignoring duplicate component with id " + componentId);
                    }
                } else{
                    log.warn('Could not handle element: ' + el);
                }
            });
    };

    return command;

};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var Component = function (id, connectionId, element, container, rayoClient, mixerName) {
    
	this.id = id;
	this.connectionId = connectionId;
    this.element = element;
    this.container = container;
    this.client = rayoClient;
    this.mixerName = mixerName;
};

// Mix in eventing
util.inherits(Component, events.EventEmitter);

Component.prototype.stop = function () {
    this.command('stop', {'xmlns': 'urn:xmpp:rayo:ext:1'}).send();
};

Component.prototype.command = function (name, attr) {

    // Init attributes is they are null
    var _attr = attr ? attr : {};

    // Add Rayo Command namespace
    if (!_attr.xmlns) {
        _attr.xmlns = RAYO_NAMESPACE_BASE + ':' + this.element.getName() + ':' + RAYO_VERSION;
    }

    // Create XML
    var command = new XmlElement(name, _attr);

    // Add the send() method
    var _this = this;
    var smid = getAndIncreaseSmid(_this.client, _this.container.callId);

    command.send = function (callback) {
    	
    	// As a command could be sent via setTimeout we rather check on client side if the call still exists
    	// instead of wasting bandwith
    	if (_this.client.rayoCalls[_this.container.connectionId]) { // does the call leg still exist?
	        _this.client.send({
	        	smid: smid,
	            callId: _this.container.callId,
	            connectionId: _this.connectionId, // this will be undefined if the component was linked to the Tropo call
	            rayoUrl: _this.container.rayoUrl,
	            authToken: _this.container.authToken,
	            componentId: _this.id,
	            body: command
	        }, _this, callback);
    	} else {
    		// emit on call object
    		_this.emit('error', new Error('Tropo Call [' + _this.container.callId + '], Connection [' + _this.connectionId + '] has ended.'));
    	}
    };

    return command;
};

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var Subscription = function (element) {
    
	var _this = this;
    this.address = element.getChild('address').getText();
    try {
    	var configData = element.getChild('config');
        this.config = configData ? JSON.parse(configData.getText()) : null;
    } catch (e) {
    	log.error("Coult not parse subscription config data:" + configData.getText());
    }
    if (element.getChild('permission') !== 'undefined') {
	    this.permissions = [];
	    var permissions = element.getChildren('permission');
	    permissions.forEach(function (permission) {
	    	_this.permissions.push(permission.attrs.name);
	    });
    }
    this.priority = element.getChild('priority') ? element.getChild('priority').getText() : null;
    this.required = element.getChild('required') ? element.getChild('required').getText() : null;
};


