/*global exports,process,require,console*/

var archiver = require('archiver'),
	cli = require('../cli'),
    fs = require('fs'),
    path = require('path'),
    util = require('util'),
    uuid = require('node-uuid'),
    repo = require('../repo'),
    prettylayout = require('../pretty-layout'),
    semver = require('semver'),
    zlib = require('zlib'),
    creds = require('../creds');

var log = cli.log;
var prompt = cli.prompt;

exports.list = function (arg, callback) {
	var params = {
			revision: cli.username,
			includeSubscriptionCount: true,
			includeInstanceCount: true
	};
    repo.Revisions.list(params,function (err, data) {
        var pl;
        if (data) {
            if (data.length === 0) {
                console.log("No revisions found.");
            } else {
                pl = prettylayout;
                pl.header(["Revision Id", "Revision Name", "Application Id", "Version", "Subscription Count", "Instance Count", "State"]);
                for (var idx = 0; idx < data.length; idx++) {
                    var entity = data[idx];
                    var nameToDisplay;
                    nameToDisplay = entity.displayName;
                    if (!nameToDisplay) {
                        nameToDisplay = entity.name;
                    }
                    pl.row([entity.id,
                        nameToDisplay,
                        entity.applicationId,
                        entity.version,
                        entity.subscriptionCount,
                        entity.instanceCount,
                        entity.state]);
                }
                pl.paint();
            }
        }
        callback(err, data);
    });
};

var get = function (arg, callback) {
    if (arg) {
        repo.Revisions.findWAccept(arg, "application/json", function (err, data) {
            if (data) {
                log.data(util.inspect(data));
            }
            callback(err, data);
        });
        return;
    }
    var schema = {
        properties: {
            revisionId: {
                required: true
            }
        }
    };

    prompt.get(schema, function (err, result) {
        if (err) {
            callback(err);
            return;
        }

        var revisionId = result.revisionId;
        repo.Revisions.findWAccept(revisionId, "application/json", function (err, data) {
            if (data) {
                log.data(util.inspect(data));
            }
            callback(err, data);
        });
    });
};
exports.get = get;

exports.rm = function (arg, callback) {
    if (arg) {
        repo.Revisions.delete(arg, function (err, data) {
            callback(err, data);
        });
        return;
    }
    var schema = {
        properties: {
            revisionId: {
                required: true
            }
        }
    };

    prompt.get(schema, function (err, result) {
        if (err) {
            callback(err);
            return;
        }

        var revisionId = result.revisionId;
        repo.Revisions.delete(revisionId, function (err, data) {
            callback(err, data);
        });
    });
};

// help command displaying the list of supported commands
// (the list is expanding as the implementation progresses)
exports.help = function (arg, callback) {
    console.log("Commands:");
    console.log("          version");
    console.log("          init");
    console.log("          deploy");
    console.log("          login");
    console.log("          revisions list | get <id>");
    console.log("          tailf [revisionId]");
};

exports.deploy = function (arg, callback) {
    var metadata;
    var cwd;
    var tarballPath;
    var remaining = '';
    var onData = function (chunk) {
        if (chunk) {
            remaining += chunk;
            var idx = remaining.indexOf('\n');
            while (idx != -1) {
                var line = remaining.substring(0, idx);
                remaining = remaining.substring(idx + 1);
                console.log(line);
                idx = remaining.indexOf('\n');
            }
        }
    };


    // Execution starts here

    metadata = initMetadata();

    createTarball(metadata, function(err, tarballPath) {
    	if (err) {
            fs.unlink(tarballPath);
            return callback(err);
    	}
    	
        var onEnd = function (error) {
            fs.unlink(tarballPath);
            
            if (error) {
                return callback(error);
            } else {
            	return checkRevisionStatus(metadata, callback);
            }
        };

    	
        // command succeeded, and data might have some info
        var stat = fs.statSync(tarballPath);
        var size = stat.size;
        var istream = fs.createReadStream(tarballPath);
        repo.Revisions.postBundle(istream, size, onData, onEnd, function (err) {
            fs.unlink(tarballPath);
        	return callback(err);
        });
    });
};

function checkRevisionStatus(metadata, callback) {
	// check the status 
	var params = {
		latestOnly: true,
		applicationUuid: metadata.package.tropo.uuid
	};
	repo.Revisions.list(params,function (err,data) {
		if (err) {
			return callback(err);
		} else if (data && data.length) {
			var revision = data[0];
			if (revision.state != 'synced') {
				return callback(new Error('Deployment failed'));
			} else {
				return callback();
			}
		}
	});
}

function createTarball(metadata, callback) {
    var tarballName = metadata.package.name + '-' + metadata.package.version + '.tgz';
    cwd = process.cwd();
    console.log('Deploying revision at ' + cwd);
    tarballPath = cwd + '/' + tarballName;
    var ostream = fs.createWriteStream(tarballPath);
    var archive = archiver('tar');
    archive.pipe(zlib.createGzip()).pipe(ostream);
    archive.bulk([{ expand : true, 
        src : ['**', '!' + tarballName],
    	dest : 'package'}]);
    archive.finalize();
    ostream.on('error', function(err) { 
    	return callback(err,tarballPath); 
	});
    ostream.on('finish', function() { 
    	return callback(null,tarballPath); 
	});
}

function initMetadata() {
    var metadata = require('../metadata');
    var data = metadata.load(true);
    if (!data.package.tropo) {
        data.package.tropo = {};
    }
    if (!data.package.tropo.uuid) {
    	data.package.tropo.uuid = uuid.v4();
    }
    if (!data.package.version) {
    	data.package.version = '0.0.0';
    }
    if (!data.package.engines) {
    	data.package.engines = {
        		node: '0.10'
        };
    }
    data.save();
    return data;
}

exports.init = function (arg, callback) {
    var config = {};
    tropoInit(function (err, data) {
        var mainFile;

        if (err) {
            return callback(err);
        }
        initMetadata();
        // log.info('Success ' + JSON.stringify(data));
        mainFile = data.main;
        var hello = require.resolve("../templates/hello.js");
        fs.readFile(hello, 'utf8', function (err, data) {
            if (err) throw err;
            fs.writeFile(mainFile, data, function (err) {
                if (err) throw err;
                log.info("Success");
            });
        });
    });
};

function tropoInit(callback) {
	var prompt = cli.prompt;
	var schema = {properties: {
        name: {
            required: true,
            default: path.basename(process.cwd())
        },
        version: {
            required: true,
            default: '0.0.0'
        },
        description: {
            required: false
        },
        tropoSdk: {
        	description : 'tropo SDK version',
            required: true,
            default: cli.version
        },
        main: {
        	description : 'entry point',
            required: true,
            default: 'index.js'
        },
        author: {
            required: false
        },
        license: {
            required: false
        }
    }};

    // add prompt option in case there is not .tropoconf in the
    // local directory
    if (!fs.existsSync(process.cwd() + "/.tropoconf")) {
        schema.properties.createLocalTropoConf = {
            description: 'creating a local .tropoconf',
            required: false,
            default: false,
            validator: /true|false/
        };
    }

    prompt.get(schema, function (err,result) {
        if (err) {
            return callback(err);
        }

        if (result.createLocalTropoConf && result.createLocalTropoConf.indexOf("true") > -1) {
            // console.log("Creating local .tropoconf");
            cli.config.stores.file.file = process.cwd() + "/.tropoconf";
            // reusing the prompt functionality of creds directly here
            // in order to ask for provisioning server url, user name and user password
            creds.prompt(function(err) {
                if (err) {
                    callback(err);
                }
                createPackageJson(result, callback);
            });
        } else {
            createPackageJson(result, callback);
        }
	});
}

function createPackageJson(result, callback) {
    "use strict";
    var sdk = result.tropoSdk;
    delete result.tropoSdk;
    result.dependencies = { tropo : sdk };
    result.scripts = { start : 'node ' + result.main };
    result.engines = {
        node: "0.10"
    };

    var contents = JSON.stringify(result, null, "  ");
    fs.writeFileSync('package.json', contents);
    if (callback) {
        callback(null, result);
    }
}
