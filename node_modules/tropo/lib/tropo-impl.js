/*global module, process, require*/

var assert = require('assert'),
    Rayo = require('./rayo'),
    util = require('util'),
    events = require('events'),
    log = require('winston'),
    saySupport = require('./say'),
    recordSupport = require('./record'),
    listenSupport = require('./listen'),
    askSupport = require('./ask'),
    request = require('request'),
    AmecheUri = require('../lib/uri');

// Constructor
var Tropo = module.exports = function () {
    this.Grammar = listenSupport.Grammar;
    this.log = log;
};

// Mix in events
util.inherits(Tropo, events.EventEmitter);

/*
 * Main entry point for the Tropo Runtime SDK. In order to protect inner implementation we must define
 * all public functions in this init function so that the Rayo Client and other internal don't leak out.
 *
 * @param {object} transportConfig The transport configuration
 * @param {string} transportConfig.type The identifier for the type of transport to use (e.g. xmpp, http)
 */
Tropo.prototype.init = function (config) {
    // Protect against multiple initializations
    if (this.initialized === true) {
        this.emit('error', new Error('Already Initialized'));
        return;
    }
    this.initialized = true;
    this.debug = false;
    this.defaultAutoConnect = true;
    this.defaultPermissions = config.defaultPermissions;

    var _this = this;

    // Init call 'store'
    var calls = {};

    var rayo = null;

    var initRayo = function () {

        // Load the transport (HTTP or XMP P)
        var Transport = null;

        try {
            Transport = require('./rayo-' + config.rayoTransportConfig.type);
        }
        catch(err) {
            log.info('Loading external transport \'%s\'', config.rayoTransportConfig.type);
            Transport = require(config.rayoTransportConfig.type);   
        }
        
        // Init the Rayo Client
        rayo = new Rayo(config.rayoConfig, new Transport(config.rayoTransportConfig, _this));
        if (config.rayoTransportConfig.type == 'mock') {
            _this.mockTransport = rayo.transport;
        }

        // Incoming / Outgoing Calls
        rayo.on('offer', function (rayoCall) {
            var offer = rayoCall.offer;

            var subscriberNumber = rayoCall.subscriber;
            var direction = offer.attrs.direction;
            if (typeof subscriberNumber == "undefined") {
                // legacy fallback
                // If it's an incoming all then the subscriber's number will be in the TO header
                // Otherwise it's an outgoing call and the call will be coming FROM the subscriber
                subscriberNumber = isInbound(direction) ? offer.attrs.to : offer.attrs.from;
            }
            var subscriber;
            if (rayoCall.subscription !== undefined) {
                var subscription = rayoCall.subscription;
                subscriber = new Subscriber(subscription.address, subscription.config, subscription.permissions, subscription.priority, subscription.required);
                
            } else {
                subscriber = new Subscriber(subscriberNumber, null, _this.defaultPermissions, null, null); 
            }
            _this.emit('subscribe', { subscriber: subscriber });

            // Construct a new call object
            var call = new Call(rayo, rayoCall, subscriber, direction, _this);
            rayo.registerTropoHandler(call);

            // Add the initiating connection to the call
            var connection = new Connection(call, [call.from], offer.headers);
            if (!isEmpty(call.from)) { // checking as from might be masked
                connection.address = call.from;
            }
            connection._addRayoCall(call.from, rayoCall);

            call.addConnection(connection);

            // This handler will be added to the end of the 'call:incoming' or 'call:outgoing'
            // EventEmiter chain and check to see if call.intercept() was called.
            // If not, the SDK will automatically send a <continue/> commmand to the rayo server.
            var interceptHandler = function (event) {
                var call = event.call;
                if (!call.rejected && !call.continueSent && !call.connectSent && !call.answerSent && call.autoConnect) {
                    if (call.subscriber.permissions && call.subscriber.permissions.indexOf("CALL_RING_LIST") > -1) {
                        call.connect();
                    } else {
                        log.debug("Subscriber " + call.subscriber.id + " does not have CALL_RING_LIST permission. Skipping continue command");
                    }                   
                }
            };

            var startingEventsHandler = function(event) {
                var eventData = {
                    address: subscriberNumber,
                    connection: connection,
                    call: call,
                    headers: event.headers,
                    subscriber: call.subscriber
                };

                connection._setState(rayoCall.connectionId, 'ringing');
                connection.emit('ringing', eventData);
                call.emit('connection:ringing', eventData);
                connection._setState(rayoCall.connectionId, 'connected');
                connection.emit('connected', eventData);
                call.emit('connection:connected', eventData);
            };
            
            if (call.isInbound()) {
                log.debug('Emitting call_incoming');
                _this.once('call:incoming', startingEventsHandler);
                _this.once('call:incoming', interceptHandler);
                
                call.subscriber.emit('call:incoming', { // legacy
                    call: call  
                }); 
                _this.emit('call:incoming', {
                    call: call,
                    subscriber:call.subscriber
                });
                
            } else {
                log.debug('Emitting call_outgoing');
                _this.once('call:outgoing', startingEventsHandler);
                _this.once('call:outgoing', interceptHandler);
                
                call.subscriber.emit('call:outgoing', {  // legacy
                    call: call
                });
                _this.emit('call:outgoing', {
                    call: call,
                    subscriber:call.subscriber
                });
            }

            // Register Call
            calls[call.id] = call;
            
            // Handle active speaker events
            rayoCall.on('started-speaking', function(event) {
                log.debug("Emitting speaking:start in call " + call);
                call.emit('speaking:start', {connection: connection, headers: event.headers});
            });
            rayoCall.on('stopped-speaking', function(event) {
                log.debug("Emitting speaking:stop in call " + call);
                call.emit('speaking:stop', {connection: connection, headers: event.headers});
            });
            
            // Handle hangup
            rayoCall.on('end', function (endEvent) {   
                var reason = null;
                if (endEvent.children && endEvent.children.length) {
                    reason = endEvent.children[0].getName();
                }
                var eventData = {
                    address: subscriberNumber,
                    connection: connection,
                    call: call,
                    headers: endEvent.headers,
                    subscriber: call.subscriber,
                    reason: reason
                };                     

                call.removeConnection(connection);
                var oldState = connection.state;
                connection._setState(rayoCall.connectionId, 'disconnected');
                if (oldState == 'connected' && connection.state == 'disconnected') {
                    connection.emit('disconnected', eventData);
                    call.emit('connection:disconnected', eventData);
                }
            });
        });

        // B-Leg Announcement
        rayo.on('joining', function (peerRayoCall, peerAddress) {

            log.debug('Received joining event. Tropo call: ' + peerRayoCall.callId + '. Rayo leg: ' + peerRayoCall.connectionId + '. Peer address: ' + peerAddress);
            var tropoCall = calls[peerRayoCall.callId];

            if (tropoCall === null) {
                return log.warn('Got join notification for unknown call [parentCallId=' + parentCallId + ']');
            }

            var peerConnection = tropoCall.findRinglistConnectionByAddress(peerAddress);
            log.debug('Found connection associated to joining event: ' + peerConnection);
            if (peerConnection !== null) {
                peerConnection._addRayoCall(peerAddress, peerRayoCall);

                var eventData = {
                    address: peerAddress,
                    connection: peerConnection,
                    call: tropoCall,
                    subscriber: tropoCall.subscriber
                };

                peerRayoCall.on('ringing', function (ringingEvent) {
                    if (peerConnection._rayoStates[peerRayoCall.connectionId].state == 'initial') {
                        peerConnection._setState(peerRayoCall.connectionId, 'ringing');
                        eventData.headers = ringingEvent.headers;
                        tropoCall.emit('connection:ringing', eventData);
                        peerConnection.emit('ringing', eventData);
                    }
                });
                
                peerRayoCall.on('joined', function (joinedEvent) {
                    log.debug("Received joined event on peer call. Peer connection state:" + peerConnection.state);
                    if (peerConnection.state != 'connected') {
                        eventData.headers = joinedEvent.headers;
                        peerConnection._setState(peerRayoCall.connectionId, 'connected');
                        peerConnection.address = new AmecheUri(eventData.address);
                        log.debug('Peer connection address: ' + util.inspect(peerConnection.address));
                        log.debug('Emitting connection:connected. Is tropo call connected? ' + tropoCall.connected);
                        tropoCall.emit('connection:connected', eventData);
                        peerConnection.emit('connected', eventData);                        
                        if (!tropoCall.connected) {
                            tropoCall.connected = true;
                            //log.debug('Tropo call subscriber is: ' + util.inspect(tropoCall.subscriber));
                            tropoCall.subscriber.emit('call:connected', eventData); // legacy
                            _this.emit('call:connected', eventData);
                        }
                    }
                });
                
                // Handle active speaker events
                peerRayoCall.on('started-speaking', function(event) {
                    tropoCall.emit('speaking:start', {connection: peerConnection, headers: event.headers});
                });
                peerRayoCall.on('stopped-speaking', function(event) {
                    tropoCall.emit('speaking:stop', {connection: peerConnection, headers: event.headers});
                });


                peerRayoCall.on('end', function (endEvent) {
                    var reason = null;
                    if (endEvent.children && endEvent.children.length) {
                        reason = endEvent.children[0].getName();
                    }
                    eventData.reason = reason;

                    var oldState = peerConnection.state;
                    peerConnection._setState(peerRayoCall.connectionId, 'disconnected');
                    log.debug('Peer received end. Old connection state: ' + oldState + '. Peer connection state: ' + peerConnection.state);
                    if (oldState != 'disconnected' && peerConnection.state == 'disconnected') { // this second condition deals with ringlists
                        log.debug('Disconnecting from peer');
                        tropoCall.removeConnection(peerConnection);
                        eventData.headers = endEvent.headers;
                        peerConnection.emit('disconnected', eventData);
                        tropoCall.emit('connection:disconnected', eventData);
                    }
                });
            }
        });

        rayo.on('end', function(event) {
            // global Tropo Call end
            log.debug('Got end event: ' + util.inspect(event));
            var call = calls[event.id];
            if (call) {
                call.dispose(event.reason);
                delete calls[event.id];
            }
        }); 

        // Bubble Rayo errors (for now)
        rayo.on('error', function (error) {
            _this.emit('error', error);
        });
    };

    _this.on('shutdown', function () {
        if (rayo !== null) {
            rayo.dispose();
            rayo = null;
        }
    });
    
    initRayo();
};

Tropo.prototype.shutdown = function (config) {

    this.emit('shutdown');
};


function handleEndEvent(call) {
    
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var Subscriber = function (id, config, permissions, priority, required) {
    this.id = id;
    this.address = new AmecheUri(id);
    this.config = config;
    this.permissions = permissions;
    this.priority = priority;
    this.required = required;
};

// Mix in events
util.inherits(Subscriber, events.EventEmitter);

// Legacy
Subscriber.prototype.__defineGetter__("number", function () {
    return this.address.address;
});


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var Call = function (rayo, rayoCall, subscriber, direction, tropo) {
    
    this.id = rayoCall.callId;
    this.rayo = rayo;
    this.rayoCall = rayoCall;
    this.direction = direction;
    this.subscriber = subscriber;
    this.tropo = tropo;
    this.autoConnect = tropo.defaultAutoConnect;
    this.authToken = rayoCall.authToken;

    this.connections = [];
    this.continueSent = false;
    this.connected = false;
    assert(this.direction == 'in' || this.direction == 'out');
};

// Mix in events
util.inherits(Call, events.EventEmitter);

Call.prototype.toString = function () {
    var result = "id=" + this.id +
        " direction=" + this.direction +
        " to=" + this.to +
        " from=" + this.from +
        " connections=[";
    var comma = '';
    this.connections.forEach(function (conn) {
        result += comma + conn;
        comma = ', ';
    });
    return result + "]";
};

Call.prototype.addConnection = function (connection) {
    var _this = this;
    this.connections.push(connection);
    log.debug('Updated connection count', { count: _this.connections.length });
    this.emit('connection:created', { call: _this, subscriber: _this.subscriber, connection: connection });
};

Call.prototype.removeConnection = function (oldConnection) {
    var _this = this;
    log.debug('Removing connection ', { call: _this.id, address: oldConnection.address?oldConnection.address.toURI() :'undefined' });
    //log.debug('Connection count before removing connection: ', { count: _this.connections.length });
    this.connections = this.connections.filter(function (connection) {
        return (connection !== oldConnection);
    });
    log.debug('Updated connection count', { count: _this.connections.length });
};

function sameAddress(address1, address2) {

    if (address1 == address2) {
        return true;
    }
    
    if (address1 === undefined || address2 === undefined) {
        return false;
    }
    var parts1 = address1.split(';');
    var parts2 = address2.split(';');
    return parts1[0] === parts2[0];
}

function buildError(call, error) {

    return { call: call, subscriber: call.subscriber, error: error };
}

Call.prototype.findRinglistConnectionByAddress = function (peerAddress) {

    var sipAddress;
    var telPlusAddress;
    if (peerAddress.indexOf('sip:') == -1 && peerAddress.indexOf('@') != -1) {
        // Tropo's "normalized" address
        sipAddress = 'sip:' + peerAddress;
    } else if (peerAddress.indexOf('tel:') != -1 && peerAddress.indexOf('tel:+') == -1) {
        telPlusAddress = 'tel:+' + peerAddress.substring(4);
    }       
        
    //log.debug("Iterating through " + this.connections.length + " connections");
    for (i = 0; i < this.connections.length; i++) {
        var connection = this.connections[i];
        //log.debug("Connection state: " + connection.state + ". Ringlist: " + connection.ringlist);
        if (connection.state == 'initial') {
            for (j = 0; j < connection.ringlist.length; j++) {
                var address = connection.ringlist[j].toURI();
                if (address.substring(0,4) === 'sip:' && address.trim().lastIndexOf(":") > 3) { //sip:..:port
                    address = address.substring(0, address.lastIndexOf(":"));
                    //log.debug('Setting new address: ' + address);
                }
                //log.debug("Comparing " + address + " with " + peerAddress + " and " + sipAddress);
                if (sameAddress(address, peerAddress) ||
                    sameAddress(address, sipAddress) ||
                    sameAddress(address, telPlusAddress)) {
                    return connection;
                }                
            }
        }
    }
    return null;
};

Call.prototype.__defineGetter__("to", function () {
    return new AmecheUri(this.rayoCall.offer.attrs.to);
});

Call.prototype.__defineGetter__("from", function () {
    return new AmecheUri(this.rayoCall.offer.attrs.from);
});

Call.prototype.isInbound = function () {
    return isInbound(this.direction);
};

Call.prototype.answer = function (callback) {

    if (this.rejected) {
        return this.emit('error', buildError(this,new Error('Call already rejected')));
    }
    if (this.connected) {
        return this.emit('error', buildError(this,new Error('Call already connected')));
    }
    if (this.connectSent) {
        return this.emit('error', buildError(this,new Error('A connect request has already been sent')));
    }
    if (this.continueSent) {
        return this.emit('error', buildError(this, new Error('A continue request has already been sent')));
    }
    if (this.answerSent) {
        return this.emit('error', buildError(this, new Error('An answer request has already been sent')));
    }
    var _this = this;
    this.rayoCall.command('answer').send(function(err, obj) {
        
        if (err) {
            _this.emit('error', buildError(_this, err));
        } else {
            var eventData = {
                    call: _this
                };
            _this.emit('answered', eventData);
        }
        if (callback) {
            callback(err, obj);
        }
    });
    _this.answerSent = true;
};

Call.prototype.connect = function () {
    
    var result;
    var _attr;
    var _this = this;
    
    if (this.rejected) {
        throw new Error('Call already rejected');
    } else if (arguments.length === 0 || (arguments.length == 1 &&
            !Array.isArray(arguments[0]) && typeof arguments[0] !== 'string')) {

        if (!this.continueSent && !this.connectSent) {
            if (arguments.length === 0) {
                this.rayoCall.command('continue').send();
            } else {
                this.rayoCall.command('continue', null, arguments[0]).send();               
            }
            this.continueSent = true;
            result = new Connection(this, [this.to]);
            result.on('error', function(error) {
                // We add this event handler for backwards compatibility to avoid breaking apps on 
                // connect errors still letting them to caught this sort of errors
                log.warn("Error sending connect request", { error: error });
             });
            
            this.addConnection(result);
        } else {
            log.warn('Continue already sent');
        }
    } else {
        var addies = arguments[0];
        if (!Array.isArray(addies)) {
            if (typeof addies === 'string') {
                addies = [addies];
            } else if (typeof addies === 'object') {
                if (addies.value && addies.type) {
                    addies = [addies.value];
                }
            }
        }
        if (arguments.length > 1) {
            _attr = arguments[1] !== null ? arguments[1] : {};
        }
        var uris = [];
        for (var i = 0; i < addies.length; i++) {
            if (typeof addies[i] === 'object' && addies[i].value && addies[i].type) {
                uris.push(addies[i]);
            } else {
                var uri = new AmecheUri(addies[i]);
                if (uri.type) {
                    uris.push(uri.toURI());
                } else {
                    // unknown URI. Still send it. Must be some arbitrary string
                    uris.push(addies[i]);
                }
            }
        }
        var headers = {};
        if (_attr) {
            headers = _attr.headers;
        }
        result = new Connection(this, uris, _attr !== null ? headers : {});     
        result.on('error', function(error) {
            // We add this event handler for backwards compatibility to avoid breaking apps on 
            // connect errors still letting them to caught this sort of errors
            log.warn("Error sending connect request", { error: error });
         });
           
        this.rayoCall.connect(uris, _attr, function(err) {
            if (err) {
                // Connect error. Remove the connection and set all rayo states as disconnected
                _this.removeConnection(result);
                result.emit('error', err);
                _this.emit('error', buildError(_this, err));
            }
        });
        _this.connectSent = true;

        this.addConnection(result);
    }
    
    return result;
};

Call.prototype.reject = function () {

    var _this = this;
    this.rejected = true;
    this.rayoCall.command('reject').c('decline').up().send(function(error) {
        if (error) {
            _this.emit('error', buildError(_this, error));
        }
    });
};

Call.prototype.say = function () {

    var args = Array.prototype.slice.call(arguments, 0);
    return saySupport.say(this, args);
};

Call.prototype.record = function (options) {

    log.debug('Call recording');
    return recordSupport.record(this, options);
};

Call.prototype.disconnect = function () {

    if (this.connected) {
        this.rayoCall.command('hangup').send();
    } else {
        log.debug('Ignoring disconnect command. Call is already disconnected');
    }
};

Call.prototype.dispose = function(reason) {
    
    log.debug('Call has no connections. Emitting end event on call and subscriber');
    this.emit('end', {
        call: this,
        subscriber: this.subscriber,
        reason: reason
    });
    this.subscriber.emit('call:end', { // legacy
        call: this,
        reason: reason
    });
    
    // Emit on tropo
    this.tropo.emit('call:end', { 
        call: this,
        subscriber: this.subscriber,
        reason: reason
    });
};


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

var CONNECTION_STATES = ['disconnected', 'initial', 'ringing', 'connected' ];

var Connection = function (call, addresses, headers) {

    this.call = call;
    this.ringlist = [];
    this.headers = typeof headers !== 'undefined' ? headers : [];
    for (var i=0; i<addresses.length; i++) {
        if (typeof addresses[i] === 'string') {
            var uri = new AmecheUri(addresses[i]);          
            if (uri.type) {
                this.ringlist.push(uri);
            } else {
                // Unknown uri type. We will use the string value
                this.ringlist.push(addresses[i]);
            }
        } else {
            this.ringlist.push(addresses[i]);
        }
    }
    this._rayos = {};
    this._rayoStates = {};
    this.address = undefined;
};

// Mix in events
util.inherits(Connection, events.EventEmitter);

Connection.prototype.toString = function () {
    var result = "state=" + this.state +
        " address=" + this.address +
        " ringlist=" + this.ringlist;
    return result;
};

Connection.prototype.disconnect = function (options) {
    
    var rayo = this._rayo;
    if (rayo) {
        var state = this._rayoStates[rayo.id];
        log.debug("Connection state when disconnecting: " + state + " " + rayo.id);
        if (state != 'disconnected') {
            rayo.command('hangup', rayo.connectionId).send();
        }
    }
};

Connection.prototype.say = function () {

    var args = Array.prototype.slice.call(arguments, 0);
    return saySupport.connectionSay(this, args);
};

Connection.prototype.record = function (options) {

    log.debug('Connection recording');
    return recordSupport.connectionRecord(this, options);
};

Connection.prototype.listen = function () {

    var args = Array.prototype.slice.call(arguments, 0);
    return listenSupport.listen(this, args);
};

Connection.prototype.ask = function () {

    var args = Array.prototype.slice.call(arguments, 0);
    return askSupport.ask(this, args);
};

Connection.prototype._addRayoCall = function (address, rayoCall) {
    this._rayos[rayoCall.connectionId] = rayoCall;
    this._rayoStates[rayoCall.connectionId] = { state: 'initial', address: address };
};

Connection.prototype._setState = function (rayoCallId, state) {
    this._rayoStates[rayoCallId].state = state;
};


Connection.prototype.__defineGetter__("state", function () {
    var result = -1;
    var states = this._rayoStates;
    var id;
    for (id in states) {
        var state = states[id].state;
        var idx = CONNECTION_STATES.indexOf(state);
        result = Math.max(idx, result);
    }

    if (result < 0 || result >= CONNECTION_STATES.length) {
        if (Object.keys(states).length > 0) {
            throw new Error("Invalid Connection state");
        } else {
            result = 'initial';
        }
    } else {
        result = CONNECTION_STATES[result];
    }

    return result;
});


Connection.prototype.__defineGetter__("_rayo", function () {
    var result;
    var states = this._rayoStates;
    var id;
    //log.debug("Fetching _rayo. States: " + util.inspect(states) + ". Rayos: " + util.inspect(this._rayos));
    for (id in states) {
        var state = states[id].state;
        if (state == 'connected') {
            result = this._rayos[id];
            break;
        }
    }
    return result;
});


Connection.prototype.__defineSetter__("state", function () {
    throw new Error('Not implemented');
});


function isInbound(direction) {
    return direction == 'in' || direction == 'term';
}

function isEmpty(obj) {
    
    return !Object.keys(obj).length;
}
