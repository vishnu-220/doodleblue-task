/*global module,require*/

var cli = require('flatiron').app,
    HTTP = require('http'),
    HTTPS = require('https'),
    util = require('util'),
	winston = require('winston');

var conf = cli.config;
var log = cli.log;

function getHttp(url) {
	if (url && ((url.indexOf && url.indexOf('https:') === 0) || (url.scheme == 'https'))) {
		return HTTPS;
	} else {
		return HTTP;
	}
}

function Resource(client, settings, path) {
    this.client = client;
    this.basePath = settings.basePath;
    this.path = path;
    if (this.path === null) {
        this.path = '';
    }
    this.username = settings.username;
    this.settings = settings;
    this.url = require('url').parse(settings.url);
}

function processResponse(err, req, res, obj, cb) {
    // debugging
    // console.log(res.statusCode);

	if (res && res.statusCode != 200) {
		var error = new Error();
		error.statusCode = res.statusCode;
		
		if (obj && obj.error) {
			error.message = obj.error;
		} else if (res && res.statusCode == 401) {
            error.message = 'Invalid username/password';
        } else if (res && res.statusCode == 403) {
	        error.message = 'Unauthorized access';
	    } else if (res && res.statusCode == 404) {
	    	error.message = 'Entity not found or Tropo provisioning is not available';
	    } else if (res && res.statusCode == 409) {
	    	error.message = 'Entity already specified';
	    } else if (res && res.statusCode == 500) {
	        error.message = 'Internal server error';
	    } else if (res && res.statusCode == 503) {
	        error.message = 'Cloud is not accessible or application instance is not accessible';
	    } else {
	    	error.message = 'Error: ' + error.statusCode;
	    }
		cb(error);
	} else if (obj && obj.error) {
		cb(new Error(obj.error));
	} else {
		cb(err,obj);
	}
}	

Resource.prototype.list = function (params, cb) {
    var path = this.basePath + this.path + "?" + "index=0&max=100000";
    if (params) {
    	if (typeof params === 'function') {
    		cb = params;
    	} else {
        	path += '&' + require("querystring").stringify(params);
    	}
    }
    this.client.get(path, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
};

Resource.prototype.find = function (id, cb) {
    return this.findWAccept(id, null, cb);
};

Resource.prototype.findWAccept = function (id, acceptHeaderValue, cb) {
    var opts;

    // flow deviation for testing of 'tropo clouds update 1'
    // cb(null, {
    //    id: 1,
    //    name: 'atttttt',
    //    platformUrl: 'api.10.244.0.34.xip.io',
    //    platformUseremail: 'admin',
    //    platformPassword: 'admin',
    //    defaultMaxSubscribersPerInstance: 5,
    //    defaultMinSubscriptionCapacity: 1,
    //    maxApplicationInstances: 10,
    //    defaultMinimumInstanceAge: 600,
    //    defaultMemorySizePerInstance: 64,
    //    defaultDiskSizePerInstance: 256,
    //    cfOrganization: 'Tropo',
    //    cfSpace: 'Ameche',
    //    cfAppUrlScheme: 'http',
    //    httpProxy: 'abc',
    //    httpsProxy: 'def',
    //    href: 'http://172.21.0.15:8080/rest/clouds/1'
    //});

    if (id === null) {
        console.log("Error: parameter required; check with 'tropo help'");
        return;
    } else if (id === undefined) {
        opts = {id: ""};
    } else {
        opts = {id: id};
    }

    if (typeof(id) == 'object') {
        opts = id;
    }

    if (acceptHeaderValue) {
        this.client.getWAccept(this.basePath + this.path + '/' + encodeURIComponent(opts.id), acceptHeaderValue, function (err, req, res, obj) {
            processResponse(err, req, res, obj, cb);
        });
    } else {
        this.client.get(this.basePath + this.path + '/' + encodeURIComponent(opts.id), function (err, req, res, obj) {
            processResponse(err, req, res, obj, cb);
        });
    }
};

Resource.prototype.findByPath = function (path, cb) {
    var opts;

    if (path === null) {
        console.log("Error: parameter required; check with 'tropo help'");
        return;
    } else if (path === undefined) {
        opts = {path: ""};
    } else {
        opts = {path : path};
    }

    if (typeof(path) == 'object') {
        opts = path;
    }

    this.client.get(this.basePath + this.path + '/' + path, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
};

// not yet generalized for any number of parameters; if needed, then this
// can actually be generalized
Resource.prototype.find1QueryParam = function (paramName, paramValue, cb) {
    this.client.get(this.basePath + this.path + '?' + paramName + "=" + paramValue, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
};

// TP stands for text/plain; this follows the example further down in
// the code

// not yet generalized for any number of parameters; if needed, then this
// can actually be generalized
Resource.prototype.findPath1QueryParamTP = function (pathFrag, paramName, paramValue, cb) {
    var path = this.basePath + this.path + "/" + pathFrag + '?' + paramName + "=" + paramValue;
    var auth = this.settings.username + ':' + this.settings.password;
    var opts = {
        hostname: this.url.hostname,
        port: this.url.port,
        auth: auth,
        path: path,
        headers: {
            'accept': 'text/plain'
        }
    };
    var logContent = "";
    var response;
    var onData = function (data) {
        logContent = logContent + data;
    };
    var onEnd = function () {
        if (response && response.statusCode == 404) {
            cb(new Error('Not found.'));
        } else if (response && response.statusCode == 500) {
            cb(new Error('Internal Server Error.'));
        } else if (response && response.statusCode == 503) {
            cb(new Error('Service Unavailable (Cloud might not be reachable or wrong credentials supplied).'));
        } else if (response && (response.statusCode < 200 || response.statusCode >= 300)) {
            cb(new Error('Error Code: ' + response.statusCode));
        } else {
            cb(null, logContent);
        }
    };
    var onError = function (err) {
        cb(err, null);
    };
    try {
        getHttp(this.settings.url).get(opts,function (res) {
            response = res;
            res.setEncoding('utf8');
            res.on('data', onData);
            res.on('end', onEnd);
            res.on('err', onError);
        }).on('error', function (err) {
                cb(err, null);
            });
    } catch (err) {
        cb(err, null);
    }
};

Resource.prototype.findPathNQueryParamTP = function (pathFrag, paramNameList, paramValueList, cb) {
    "use strict";
    var path;
    var i;
    var effectivePathFrag;

    if (pathFrag) {
        effectivePathFrag = "/" + pathFrag;
    } else {
        effectivePathFrag = "";
    }

    if (paramNameList.length > 0) {
        path = this.basePath + this.path + effectivePathFrag + '?' + paramNameList[0] + "=" + paramValueList[0];
        for (i = 1; i < paramNameList.length; i = i + 1) {
            path = path + "&" + paramNameList[i] + "=" + paramValueList[i];

        }
    } else {
        path = this.basePath + this.path + effectivePathFrag;
    }

    // debugging
    // console.log(path);

    var auth = this.settings.username + ':' + this.settings.password;
    var opts = {
        hostname: this.url.hostname,
        port: this.url.port,
        auth: auth,
        path: path,
        headers: {
            'accept': 'text/plain, application/json'
        }
    };
    var logContent = "";
    var response;
    var onData = function (data) {
        logContent = logContent + data;
    };
    var onEnd = function () {
        if (response && response.statusCode == 404) {
            cb(new Error('Not found.'));
        } else if (response && response.statusCode == 500) {
            cb(new Error('Internal Server Error.'));
        } else if (response && response.statusCode == 503) {
            cb(new Error('Service Unavailable (Cloud might not be reachable or wrong credentials supplied).'));
        } else if (response && response.statusCode == 400) {
            cb(new Error('Error Code: ' + response.statusCode), logContent);
        } else if (response && (response.statusCode < 200 || response.statusCode >= 300)) {
            cb(new Error('Error Code: ' + response.statusCode));
        } else {
            cb(null, logContent);
        }
    };
    var onError = function (err) {
        cb(err, null);
    };
    try {
    	getHttp(this.settings.url).get(opts,function (res) {
            response = res;
            res.setEncoding('utf8');
            res.on('data', onData);
            res.on('end', onEnd);
            res.on('err', onError);
        }).on('error', function (err) {
                cb(err, null);
            });
    } catch (err) {
        cb(err, null);
    }
}
;

Resource.prototype.create = function (body, cb) {
    this.client.post(this.basePath + this.path, body, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
};

Resource.prototype.update = function (id, body, cb) {

    this.client.put(this.basePath + this.path + '/' + encodeURIComponent(id), body, function (err, req, res, obj) {
        //log.debug('Processing response. err: ' + err + ". Response: " + util.inspect(res));
        processResponse(err, req, res, obj, cb);
    });
};

Resource.prototype.delete = function (id, cb) {
    this.client.del(this.basePath + this.path + '/' + encodeURIComponent(id), function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
};

Resource.prototype.deleteByPath = function (path, cb) {
    this.client.del(this.basePath + this.path + '/' + path, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
};

function Repo() {
    var self = this;
    var settings = {};
    settings.url = conf.get('provisioningServerUrl');
    if (typeof settings.url != "undefined") {
        settings.username = conf.get('provisioningServerUsername');
        settings.password = conf.get('provisioningServerPassword');

        var url = require('url');
        var baseUrl = url.parse(settings.url);
        
        if (baseUrl.pathname.indexOf('/', baseUrl.pathname.length - 1) !== -1) {
        	// already ends with slash
        	settings.basePath = baseUrl.pathname;
        } else {        
        	settings.basePath = baseUrl.pathname + '/';
        }
        
        var jsonClient = new JsonClient({
        	http: getHttp(settings.url),
            host: baseUrl.hostname,
            port: baseUrl.port,
            username: settings.username,
            password: settings.password
        });

        self.Apps = new Resource(jsonClient, settings, 'applications');
        self.Addresses = new Resource(jsonClient, settings, 'addresses');
        self.MyAddresses = new Resource(jsonClient, settings, 'users/' + settings.username + '/addresses');
        self.Clouds = new Resource(jsonClient, settings, 'clouds');
        self.CloudFoundries = new Resource(jsonClient, settings, 'cloudfoundries');
        self.Logs = new Resource(jsonClient, settings, undefined);
        self.Provisioning = new Resource(jsonClient, settings, 'version');
        self.Revisions = new Resource(jsonClient, settings, 'revisions');
        self.Subscriptions = new Resource(jsonClient, settings, 'subscriptions');
        self.SubscriptionReport = new Resource(jsonClient, settings, 'subscriptionreport');
        self.Users = new Resource(jsonClient, settings, 'users');

        self.Addresses.findSubscriptionsByValue = findSubscriptionsByValue;
        self.Revisions.tailf = tailf;
        self.Revisions.postBundle = postBundle;

        self.settings = settings;
    } else {
        winston.debug('Could not find any Tropo Provisioning Server Url. Running Tropo in non-provisioning mode.');
    }
}

module.exports = new Repo({});


function findSubscriptionsByValue(value, cb) {
    var client = this.client,
        basePath = this.basePath,
        path = 'addresses';

    client.get(basePath + path + '?value=' + value, function (err, req, res, obj) {
        var results = obj.results;
        if (results.length) {
            var result = results[0];
            client.get(
                basePath + path + '/' + result.id + '/subscriptions',
                function (err, req, res, results) {
                    cb(err, results);
                }
            );
        }
    });
}

/*
 * PAAS-REVIEW
function deployInstance(id, cb) {
    var client = this.client,
        basePath = this.basePath,
        path = 'instances/' + id + "/deploy";

    this.client.post(basePath + path, {}, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
}

function pingInstance(id, body, cb) {
    var client = this.client,
        basePath = this.basePath,
        path = 'instances/' + id + "/pings";

    this.client.post(basePath + path, body, function (err, req, res, obj) {
        processResponse(err, req, res, obj, cb);
    });
}
*/


function tailf(revisionId, onData, onEnd) {
	doTailf.call(this,revisionId,100,onData,onEnd);
}

function doTailf(revisionId, lines, onData, onEnd) {
	var _this = this;	
    var path = this.basePath + this.path + '/' + revisionId + '/tailf?lines=' + lines;    
    var auth = this.settings.username + ':' + this.settings.password;
    var opts = {
        hostname: this.url.hostname,
        port: this.url.port,
        auth: auth,
        path: path,
        method: 'GET',
        headers: {
            'accept': 'text/plain'
        }
    };
    var req = getHttp(_this.settings.url).request(opts, function (res) {
        if (res && res.statusCode == 401) {
            onEnd(new Error('Invalid username/password'));
        } else if (res && res.statusCode == 403) {
        	onEnd(new Error('Cloud might not be accessible or invalid security credentials.'));
        } else if (res && res.statusCode == 404) {
        	onEnd(new Error('Resource not found'));
        } else {
            res.setEncoding('utf8');
            res.on('data', onData);
            res.on('end', function(err) {
            	if (err) {
            		onEnd(err);
            	} else {
            		doTailf.call(_this, revisionId, 0, onData, onEnd);
            	}
            });
            res.on('error', onEnd);
        }
    });
    req.on('error', onEnd);
    req.end();
}

function postBundle(istream, size, onData, onEnd, onError) {
    var path = this.basePath + this.path;
    var auth = this.settings.username + ':' + this.settings.password;
    var opts = {
        hostname: this.url.hostname,
        port: this.url.port,
        auth: auth,
        path: path,
        method: 'POST',
        headers: {
            'content-type': 'application/gzip',
            'content-length': size,
            'accept': 'text/plain'
        }
    };
    // console.log(opts);

    istream.on('data', function (data) {
        req.write(data);
    });
    istream.on('end', function () {
        req.end();
    });
    istream.on('error', onEnd);

    var req = getHttp(this.settings.url).request(opts, function (res) {
        if (res && res.statusCode == 401) {
            onError(new Error('Invalid username/password'));
        } else if (res && res.statusCode == 403) {
            onError(new Error('Cloud might not be accessible or invalid security credentials.'));
        } else if (res && res.statusCode == 404) {
            onError(new Error('There must be at least one cloud.'));
        // }  else if (res && res.statusCode != 200) {
        //    onError(new Error(res.statusCode));
        } else {
            res.setEncoding('utf8');
            res.on('data', onData);
            res.on('end', onEnd);
            res.on('error', onError);
        }
    });

    req.useChunkedEncodingByDefault = false;
    req.on('error', onError);
}

function JsonClient(opts) {
    this.opts = opts;
}

JsonClient.prototype.get = function (path, callback) {
    return this._request('GET', path, null, null, callback);
};

JsonClient.prototype.getWAccept = function (path, acceptHeaderValue, callback) {
    return this._request('GET', path, acceptHeaderValue, null, callback);
};

JsonClient.prototype.del = function (path, callback) {
    return this._request('DELETE', path, null, null, callback);
};

JsonClient.prototype.put = function (path, body, callback) {
    return this._request('PUT', path, null, body, callback);
};

JsonClient.prototype.post = function (path, body, callback) {
    return this._request('POST', path, null, body, callback);
};

JsonClient.prototype._request = function (method, path, acceptHeaderValue, body, callback) {

    if (body && typeof body !== 'string') {
        body = JSON.stringify(body);
    }
    
    var opts = this.opts;
    var auth = new Buffer(opts.username + ':' + opts.password).toString('base64');
    var options = {
        host: opts.host,
        port: opts.port,
        path: path,
        method: method,
        headers: {
            'Authorization': 'Basic ' + auth,
            'Content-type': 'application/json'
        }
    };

    if (acceptHeaderValue) {
        options.headers.Accept = acceptHeaderValue;
    }

    var req = opts.http.request(options, function (res) {
        var responseBody = '';
        res.on('data', function (chunk) {
            responseBody += chunk;
        });
        res.on('end', function () {
            if (callback) {
                var err;
                var obj;
                try {
                    obj = JSON.parse(responseBody);
                } catch (parseErr) {
                    err = parseErr;
                    err.responseBody = responseBody;
                }
                callback(err, req, res, obj);
            }
        });
    });
    req.on('error', function (err) {
        if (callback) {
            callback(err);
        }
    });
    req.end(body);
};
