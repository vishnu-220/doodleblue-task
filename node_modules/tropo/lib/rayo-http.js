/*global console, module, process*/

var util = require('util'),
    events = require('events'),    
    http = require('http'),
    log = require('winston'),
    parseXml = require('./utils').parseXml,
    request = require('request'),
    url = require('url');

http.globalAgent.maxSockets = 900;

var RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE'];

/*
 * Constructs a new Rayo HTTP Transport
 * @param {object} config An object containing the configuration for this transport. (see below for properties)
 */
var Transport = module.exports = function (config, tropo) {
    
    if (config.rayoAddress) {
        config.rayoUrl = config.rayoAddress;
    }
    this.config = config;

    this.tropo = tropo;
    this.timeout = 5000; // 5 seconds default request timeout
    if ("HTTP_TIMEOUT" in process.env) {
    	this.timeout = process.env.HTTP_TIMEOUT;
    }    
    this.maxRetries = 3; // 3 retries timed out requests
    if ("HTTP_RETRIES" in process.env) {
    	this.maxRetries = process.env.HTTP_RETRIES;
    }    
    this.retryInterval = 1000; // retry after one second
    if ("HTTP_RETRY_INTERVAL" in process.env) {
    	this.retryInterval = process.env.HTTP_RETRY_INTERVAL;
    }    
};

// Mix in eventing
util.inherits(Transport, events.EventEmitter);

/*
 * Puts the transport into service. This is particularly important for transports with active connections
 * like XMPP as it allows consumers to register handlers before the transport begins taking requests.
 */
Transport.prototype.start = function () {

    var _this = this;
    var listenAddressParts = this.config.listenAddress.split(':');
    var pingResponseCode = 200;
    this.tropoMids = {};

    var serverFunction = function (req, res) {
        var requestMethod;
        var requestBody = '';
        var OK = 200;
        var BAD_REQUEST = 400;
        var NOT_FOUND = 404;
        var url_parts = url.parse(req.url, true);

        requestMethod = req.method;

        switch (url_parts.pathname) {
            case '/ping':
                log.debug("ping: request received");

                req.on('data', function (chunk) {
                    console.log("ping: got data: " + chunk);
                });

                req.on('end', function () {
                    log.debug("ping: processing");
                    var query = url_parts.query,
                        responseCodeThisInvocation;

                    if (url_parts.query.disable !== undefined) {
                        if (url_parts.query.disable === "true") {
                            log.debug("ping: future ping disabled");
                            pingResponseCode = NOT_FOUND;
                            responseCodeThisInvocation = OK;
                        } else if (url_parts.query.disable === "false") {
                            log.debug("ping: future ping enabled");
                            pingResponseCode = OK;
                        } else {
                            log.debug("ping: bad request");
                            pingResponseCode = BAD_REQUEST;
                        }
                    } else {
                        // no change; take the response code as it was set the
                        // last time around; so, once switched off, it stays off,
                        // etc.
                    }

                    if (responseCodeThisInvocation !== undefined) {
                        log.debug(req.url + ": " + "Got pinged; response code: " + responseCodeThisInvocation);
                        res.writeHead(responseCodeThisInvocation, {'Content-Type': 'text/plain'});
                    } else {
                        log.debug(req.url + ": " + "Got pinged; response code: " + pingResponseCode);
                        res.writeHead(pingResponseCode, {'Content-Type': 'text/plain'});
                    }
                    res.end();
                });
                break;
            case '/_testresult':
                res.writeHead(200, "OK", {"Content-Type": "text/plain"});
                res.write(_this.tropo._testResult);
                res.end();
            	break;
            default:
            	if (requestMethod != 'POST') {
            		break;
            	}
            
                req.on('data', function (chunk) {
                    requestBody = requestBody + chunk;
                });

                req.on('end', function () {

                    var headers = req.headers;

                    var callId = headers['call-id'];
                    var connectionId = headers['connection-id'];
                    var componentId = headers['component-id'];
                    var mixerName = headers['mixer-name'];
                    var rayoUrl = headers['rayo-url'];
                    var authToken = headers['auth-token'];
                    var subscriber = headers.subscriber;
                    var mid = headers.mid ? parseInt(headers.mid) : null;
                    
                    if (mid && callId) {
                    	var latestMid = _this.tropoMids[callId] ? _this.tropoMids[callId] : -1; 
                    	
                    	if (mid <= latestMid) {
                    		log.debug('Dropping a duplicate message');
                    		log.debug('WIRE (x): ' + requestBody,
                                {mid:mid, callId: callId, connectionId: connectionId, 
                       	        componentId: componentId, mixerName: mixerName,
                                authToken: authToken, rayoUrl: rayoUrl, 
                                subscriber: subscriber});
                    		
                            res.writeHead(203, {'Content-Type': 'text/plain'});
                            res.end();
                    		return;
                    	} else {
                    		_this.tropoMids[callId] = mid;
                    	}
                    }

                    // Emit the event after the response is written
                    res.on('finish', function () {
                        log.info('WIRE (i) ' + requestBody,
                            {mid:mid, callId: callId, connectionId: connectionId, 
                    	     componentId: componentId, mixerName: mixerName,
                             authToken: authToken, rayoUrl: rayoUrl, 
                             subscriber: subscriber});
                        
                        parseXml(requestBody, function(err,result) {
                        	if (err) {
                        		_this.emit('error', err);
                        	} else {
                                _this.emit('callEvent', {
                                	mid: mid,
                                    callId: callId,
                                    connectionId: connectionId,
                                    componentId: componentId,
                                    mixerName: mixerName,
                                    rayoUrl: rayoUrl,
                                    authToken: authToken,
                                    subscriber: subscriber,
                                    body: result
                                });
                        	}
                        });
                    });

                    var responseMap = {'Content-Type': 'text/plain'};
                    if (callId !== undefined) {
                    	responseMap['Set-Cookie'] = 'JSESSIONID=' + callId + ";max-age=" + 86400000; // Expire after a day
                    }
                    
                    res.writeHead(203, responseMap);
                    res.end();
                });
                break;
        }
    };

    var port = null;
    if ("TROPO_IN_CLOUD_FOUNDRY" in process.env) {
        // Cloud Foundry defines the port itself automatically
        port = process.env.VCAP_APP_PORT;
        if (!port) {
            // Diego support, when deploying over PWS
            port = process.env.PORT;
        }
        this._server = http.createServer(serverFunction).listen(port);
        log.debug("Listening on port: " + JSON.stringify(port));
    } else if ("TROPO_IN_APCERA" in process.env) {
        // Cloud Foundry defines the port itself automatically
        port = process.env.PORT;
        this._server = http.createServer(serverFunction).listen(port);
        log.debug("Listening on port: " + JSON.stringify(port));
    } else {
        // port and host as provided by start up parameters
        this._server = http.createServer(serverFunction).listen(
            listenAddressParts[1], listenAddressParts[0]);
            log.debug("Listening on: " + listenAddressParts[1] + " " + listenAddressParts[0]
        );
    }
    this._server.timeout = this.timeout;
};

/*
 * Sends the command to the Rayo Server. Primary API for transport clients.
 * @param {object} command An object containing the Rayo XML command and other routing information (see below)
 * @param {object} command.body An ltx object representing the Rayo XML Command
 * @param {string} command.callId The ID of the Tropo Call to which this command is targeted
 * @param {string} command.connectionId The ID of the Tropo Connection to which this command is targeted if any
 * @param {string} command.componentId The ID of the Component to which this command is targeted
 * @param {string} command.appRevisionId The ID of the AppRevision to which this command is targeted
 * @param {string} command.rayoUrl The URL of the rayo server that is associated with this Tropo Call
 * @param {string} command.authToken The authentication token required to communicate with the Rayo server
 * @param {object} callback The function responsible for handling the response from the Rayo Server
 */
Transport.prototype.send = function (command, callback) {

	var _this = this;
    var headers = {};
    headers['Content-Type'] = 'application/xml;charset=UTF-8';
    if (command.callId) {
        headers['call-id'] = command.callId;
    }
    if (command.connectionId) {
    	headers['connection-id'] = command.connectionId;
    }
    if (command.componentId) {
        headers['component-id'] = command.componentId;
    }
    if (this.config.appRevisionId) {
        headers['app-revision-id'] = this.config.appRevisionId;
    }
    if (command.smid) {
    	headers.smid = command.smid;
    }

    var rayoUrl = command.rayoUrl;
    if (!rayoUrl) {
        rayoUrl = this.config.rayoUrl;
    }

    if (command.authToken) {
        headers['auth-token'] = command.authToken;
    }


    // Create XML
    var postBody = command.body.toString();
    var commandVars = {callId: command.callId,
            connectionId: command.connectionId, componentId: command.componentId,
            authToken: command.authToken, rayoUrl: rayoUrl, smid: command.smid};
    
    log.info('WIRE (o) ' + postBody, commandVars);

    var retries = 0;
    var options = {
    	headers: headers,
        url: rayoUrl,
        timeout: this.timeout,
        retries: 0,
        body: postBody
    };
    
    var postFunction = function(err, res, body) {
    	
    	var shouldRetry = (res && 503 == res.statusCode) ||
    					  (err && RETRIABLE_ERRORS.indexOf(err.code) != -1);
    	if (shouldRetry) { 
    		if (options.retries < _this.maxRetries) {
    			if (res) {
    				log.info("Got a retriable error. Response status code: " + res.statusCode + ". Retries: " + options.retries + ". Max Retries: " + _this.maxRetries + ". Retry interval: " + _this.retryInterval);
    			} else {
    				log.info("Got a retriable error. Error code: " + err.code + ". Retries: " + options.retries + ". Max Retries: " + _this.maxRetries + ". Retry interval: " + _this.retryInterval);
    			}
    			
            	setTimeout(function() {
            		log.debug("Retrying post request.");
        			options.retries = options.retries + 1;
        			options.headers['http-retry'] = options.retries.toString();
            		request.post(options, postFunction);
            	}, _this.retryInterval);
            	return;
    		} else {
    			log.info("Request reached the maximum number of retries.");
    		}
    	}
    	        	
	    if (callback) {
	        if (err) {
	        	err.retries = options.retries;
	            callback(err);
	        } else if (res && res.statusCode == 200) {
	            log.info('WIRE (r) ' + body, {callId: command.callId, connectionId: command.connectionId, componentId: command.componentId, mixerName: command.mixerName});
	            parseXml(body, callback);
	        } else if (res && res.statusCode == 203) {
	            log.info('WIRE (r) 203.', {callId: command.callId, connectionId: command.connectionId, componentId: command.componentId, mixerName: command.mixerName});
	            callback(null, null);
	        } else {
	            if (err && res === null) {
		        	err.retries = options.retries;
	                callback(err);
	            } else {
                    if (err && res === null) {
                        err.retries = options.retries;
                        callback(err);
                    } else {
                        if (res.statusCode == 429) {
                            log.info('WIRE (r) 429. The application is sending much more requests to the server than allowed. Is there any application issue maybe?');
                        } else {
                            log.info('WIRE (r) ' + body, {callId: command.callId, connectionId: command.connectionId, componentId: command.componentId, mixerName: command.mixerName});
                        }
                        var errorMessage = 'Server Error [statusCode=' + res.statusCode +
                            ', message=' + res.headers['rayo-error'] +
                            ', command=' + postBody + 
                            ']';
                        var error = new Error(errorMessage);
                        error.retries = options.retries;
                        error.code = res.statusCode;
                        log.debug(errorMessage, commandVars);
                        callback(error);
                    }	            
	            }
	        }
	    }
    };
    
    request.post(options, postFunction);    
};
